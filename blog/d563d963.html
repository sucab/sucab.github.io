<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="bigdata, ai, 中间件、算法、大数据、人工智能"><title>Ubuntu-linux学习笔记 | Tony's Notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Ubuntu-linux学习笔记</h1><a id="logo" href="/.">Tony's Notes</a><p class="description">Stay Hungry, Stay Foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Ubuntu-linux学习笔记</h1><div class="post-meta">May 17, 2014<span> | </span><span class="category"><a href="/categories/读书笔记/">读书笔记</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 13.9k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 51</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h1 id="一、ubuntu的安装"><a href="#一、ubuntu的安装" class="headerlink" title="一、ubuntu的安装"></a>一、ubuntu的安装</h1><ol>
<li><strong>所需资源</strong>：（1）Ubuntu的iso文件，可从<a href="http://www.ubuntu.com/" target="_blank" rel="noopener">ubuntu官网</a>下载；(2)u盘刻录软件<a href="http://dl.pconline.com.cn/download/58150.html" target="_blank" rel="noopener">unetbootin</a>。</li>
<li><p><strong>安装步骤</strong>：</p>
<ol>
<li>进入bois界面，设置usb优先启动，进入ubuntu的安装界面；</li>
<li><p>一些简单的前期设置这里直接忽略，主要说明一下磁盘分区。</p>
<blockquote>
<p>1）至少需要两个磁盘分区，分别用于创建”/“文件系统与交换分区。其中，linux系统使用交换分区提供虚拟内存，在一个32位的pc中，不超过2GB。2）若磁盘存储空间较大，可划分多个磁盘分区，在每一个磁盘分区中创建一个单独的文件系统，如/usr,/var,/home等文件系统，但不能把/bin,/dev/,/etc/,/lib,/root和/sbin目录作为单独的文件系统分区，这些目录应位于”/“文件系统分区中。3）若要创建多个磁盘分区，查阅分区要求与建议。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<a id="more"></a>
<h1 id="二、命令行基础知识"><a href="#二、命令行基础知识" class="headerlink" title="二、命令行基础知识"></a>二、命令行基础知识</h1><ol>
<li><span class="red-back">对于ubunut桌面版(若为服务器版，略过)，进入终端的方式：</span><ol>
<li><code>ctrl+alt+T</code>，默认屏幕大小打开终端；</li>
<li><code>alt+F2</code>，进入执行命令文本框，输入<code>gnome-terminal --full-screen</code>，即进入全屏显示，输入<code>exit</code>，即可退到1中打开的状态；</li>
<li>非Gnome图形界面，进入字符终端，输入<code>crtl+alt+f1-6</code>，打开<code>tty1-6</code>的终端界面。输入<code>ctrl+alt+f7</code>，返回GNOME界面；</li>
<li>也可以通过设置/etc/default下的grub文件，设置开启启动到图形界面还是字符界面。</li>
</ol>
</li>
<li>Linux系统默认的命令解释程序是bash，GNU Bourne-Again Shell, 是GNU组织开发和推广的一个项目。</li>
<li><p>一个命令由以下3部分内容组成，中间以空格或制表符等空白字符隔开，形如：<strong>&lt;命令名&gt; &lt;命令选项&gt; &lt;命令参数&gt;</strong></p>
<ol>
<li>其中的命令选项以”-“开头，以”–”为起始标志的命令选项，称为<strong>GUN</strong>选项。除个别命令选项外，大部分”–”开头的是”-“的同义词，可替换使用。</li>
</ol>
</li>
<li><span class="red-back">普通用户与超级用户的切换</span><ol>
<li><strong>超级用户</strong>的默认命令提示符为”#”,<strong>普通用户</strong>的默认命令提示符为”$”；</li>
<li>在终端，键入sudo su，输入密码，进入超级用户模式；键入exit，回到普通用户模式。</li>
</ol>
</li>
<li>前后台进程切换<ol>
<li>前台形式，在shell执行命令期间，用户只能等待，不能做其他操作；</li>
<li>后台形式，在命令执行同时，shell会立即输出命令提示符，等待用户输入新的命令。<strong>只要在命令的后面加上”&amp;”即可</strong>。</li>
</ol>
</li>
<li><p>输入输出</p>
<ol>
<li>从终端输入，这个数据输入源是标准输入<strong>stdin（0）</strong>；</li>
<li>运行结果返回到终端屏幕上，这个输入目的是标准输出<strong>stdout（1）</strong>；</li>
<li><p>运行期间的错误也显示在屏幕上<strong>stderr(2)</strong>。</p>
<blockquote>
<p><strong>注意</strong>：其中（n），n指文件描述符。Linux系统启动一个进程（该进程可能用于执行Shell命令）时，将自动为该进程打开三个文件：标准输入、标准输出和标准错误输出，分别由文件标识符0、1、2标识。</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>输入输出重定向</strong></p>
<ol>
<li><p><code>&lt;fname</code>，使用指定的文件作为标准输入（其文件描述符为0），以便从指定的文件中接收输入数据；</p>
<blockquote>
<p><code>wc -l &lt; io.txt</code>,表示将io.txt中的记录行数显示到屏幕终端。</p>
</blockquote>
</li>
<li><p><code>&gt;fname</code>，使用指定的文件作为标准输出（其文件描述符为1），若文件不存在则新建，存在且noclobber标志已经设置，将产生错误，否则覆盖原文件中所有内容。若需要追加在原文件内容后面，需要用<code>&gt;&gt;fname</code>。</p>
<blockquote>
<p>例如：<code>ls -l &gt; io.txt</code>,表示将当前目录下的所有文件信息写入io.txt文件中，若io.txt没有，则自动创建，存在则直接覆盖其中的内容。</p>
</blockquote>
</li>
<li><p><code>&gt;|fname</code>,除了忽略noclobber标致之外，其功能与<code>&gt;fname</code>相同。</p>
<blockquote>
<p>注意：&gt;|符号是强制覆盖文件的符号，它与Shell的noclobber选项有关系，如果noclobber选项开启，表示不允许覆盖任何文件，而&gt;|符号则可以不管noclobber选项的作用，强制将文件覆盖。<code>set -C noclobber</code>开启noclobber，<code>set +C noclobber</code>关闭noclobber。</p>
</blockquote>
</li>
<li><code>&lt;&gt;fname</code>，以读写方式打开指定的文件，并使之作为标准输入。</li>
<li><code>&lt;&lt;[-]fstr</code>，<a href="http://zh.wikipedia.org/wiki/Here文档" target="_blank" rel="noopener">Here document</a>文档的使用技巧。</li>
<li><code>&lt;&amp;digti</code>，使用指定的文件描述符复制一个标准输入。</li>
<li><code>&gt;&amp;digti</code>，使用指定的文件描述符复制一个标准输出。</li>
<li><code>&lt;&amp;-</code>，关闭标准输入，而”n&lt;&amp;-“则表示关闭输入文件描述符n。</li>
<li><code>&gt;&amp;-</code>，关闭标准输出，而”n&gt;&amp;-“则表示关闭输出文件描述符n。</li>
<li><code>&lt;&amp;j</code>，把标准输入重定向到文件描述符j表示的输入文件中。</li>
<li><code>&gt;&amp;j</code>，把标准输出重定向到文件描述符j表示的输出文件中。</li>
<li><p><code>&amp;&gt;fname</code>，把标准输出和标准错误输出均重定向到指定的文件中。</p>
<blockquote>
<p>以下I/O重定向符号”&lt;”或”&gt;”前面有一个数字，则表示相应的文件描述符对应的文件。</p>
</blockquote>
</li>
<li><code>0&lt;fname</code>，把标准输入重定向到指定的文件中。</li>
<li><code>1&gt;fname</code>，把标准输出重定向到指定的文件中；<code>1&gt;&gt;fname</code>，把标准输出重定向并附加到指定的文件中。</li>
<li><code>2&gt;fname</code>，把标准错误输出重定向到指定的文件中；<code>2&gt;&gt;fname</code>，把标准错误输出重定向并附加到指定的文件中。例如:<blockquote>
<p><code>$ errfile=script.errors</code>(errfile就是文件描述符);<br><br><code>$ sss 2&gt;$errfile</code>，sss是错误指令，则输出错误信息，2被重定向到了errfile对应的文件中，故错误信息写在script.errors;<br><br><code>$ aaa 2&gt;&gt;$errfile</code>，继续追加错误信息；<br>cat script.errors，显示错误信息。</p>
</blockquote>
</li>
</ol>
</li>
<li><p><code>i&gt;&amp;j</code>，把文件描述符i表示的输出文件重定向到文件描述符j表示的文件中。例如：</p>
<pre><code>&gt; `command &gt;command.log 2&gt;&amp;1`，标准输出和标准错误输出都重定向到同一个文件中&lt;br&gt;
</code></pre><blockquote>
<p><code>$ echo &quot;hello&quot; &gt;&gt; command.log 2&gt;&amp;1</code><br><br><code>$ sss &quot;hello&quot; &gt;&gt; command.log 2&gt;&amp;1</code></p>
</blockquote>
<ol start="17">
<li><code>[j]&lt;&gt;fname</code>，以读写方式打开指定的文件，并把文件描述符j分配到指定的文件。如果文件不存在，则创建该文件。如果未指定文件描述符j，则表示默认的文件描述符0，即标准输入。</li>
</ol>
</li>
<li><p><strong>管道</strong></p>
<ol>
<li>基本概念：在linux系统中，<strong>管道</strong>是一种先进先出的单向数据通路。是一种特殊的管道重定向。</li>
<li><p>用途：</p>
<ol>
<li><p><span class="red-back">利用管道符号”|”,可以把一个命令的标准输出连接到另一个命令的标准输入。</span>例如：</p>
<blockquote>
<p><code>ls /usr | wc -w</code>，统计/usr目录下文件的数量（利用管道把ls和wc两个命令连接在一起）<br> 传统的方法，是利用一个中间临时文件，如<code>ls /usr &gt; file.tmp ; wc -w &lt; file.tmp</code>。</p>
</blockquote>
</li>
<li><span class="red-back">为滤通程序提供原始数据。由该程序读取来自标准输入的数据，按照指定的检索原则和模式，从输入数据中提取期望的，包含给定字符串的数据</span>，如<a href="http://zh.wikipedia.org/wiki/Grep" target="_blank" rel="noopener">grep</a>。</li>
<li>可以依次加工处理多个命令、脚本和程序的输出数据。<code>command1 | command2 | command3 &gt; output-file</code>。</li>
<li><code>tee</code>命令，一个相当于三通管的实用程序。主要功能是通过标准输入接收并显示数据，同时把数据存储到指定的文件中。</li>
</ol>
</li>
</ol>
</li>
<li><p>元字符与文件名生成</p>
<ol>
<li>linux中，很多命令采用文件名作为命令参数，例如：<blockquote>
<p><code>$ ls -l io.txt</code><br><br><code>-rw-rw-r-- 1 sucab sucab 12 5月 14 10：42 io.txt</code></p>
</blockquote>
</li>
<li><p>Shell支持的与文件名生成有关的元字符极其说明。注意，元字符可以组合使用。</p>
<ol>
<li><p><code>*</code>，可以匹配任何数量的字符或字符串，包括空字符串。例如：</p>
<blockquote>
<p><code>ls -l *.txt</code>，列出所有<code>.txt</code>为文件后缀名的txt文件。<code>su*</code>，表示任何一个以”su”为起始的字符串。</p>
</blockquote>
</li>
<li><code>?</code>，匹配单字符串。</li>
<li><code>[...]</code>，匹配给定范围的字符。例如[a-z]，[0-9]。<code>[!...]或[^...]</code>，表示不在该范围中。例如：<blockquote>
<p>列出当前目录下，以s或i开头的文件。<code>ls -l [io]*</code><br><br>列出不是a-z中字母开头的文件。ls -l [^a-z]*</p>
</blockquote>
</li>
<li><strong>注意</strong>：<code>set -f</code>，<span class="red-back">能够禁止文件名的生成。当shell无法解释元字符时，应注意检查是否设置了该标志。</span></li>
</ol>
</li>
<li>转义和引用<ol>
<li>本身具有特殊意义的元字符，在前面加上转义符号<code>\</code>，则失去其特殊意义。而对于一些普通字符，加上转义符号<code>\</code>，则具有特殊意义。例如：<blockquote>
<p><code>\a</code>,生成声音提示；<code>\b</code>退格符；<code>\e</code>Esc字符；<code>\f</code>换页符；<code>\n</code>换行符；<code>\r</code>回车符；<code>\t</code>制表符；<code>\v</code>竖向制表符；<code>\\反</code>斜线；\’单引号；<code>\nnn</code>采用1-3位8进制数值表示等价ASCII字符；<code>\xHH</code>采用1-2位16进制数值表示的等价ASCII字符；<code>\cX</code>Ctrl+X字符。<br><br>其中，<code>\n</code>换到下一行，\r`回到本行的开头。<span class="red-back">Unix系统里，每行结尾只有”\n”;Windows系统里面，每行结尾是”\n\r”；Mac系统里，每行结尾是”\r”。</span></p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li>历史命令（很强大呀！）<ol>
<li><span class="red-back">fc命令的常见用法</span><ol>
<li><code>fc -l 10 20</code>，显示命令缓冲区或文件中序号为10-20的命令；</li>
<li><code>fc -l -10</code>，列出最近输入的10条命令；</li>
<li><code>fc -l cat</code>，列出最近一次输入的以<code>cat</code>命令为其实字符串的命令；</li>
<li><code>fc -e gedit/vim 10 20</code>，要利用vim或gedit编辑并执行序号为10-20的命令</li>
<li>先执行<code>ls -l /ect/profile</code>，要想再执行一遍该指令，可以输入<code>fc -s</code>；</li>
<li><code>fc -s 100</code>，执行先前的第100号命令。</li>
</ol>
</li>
<li>history命令的常见用法<ol>
<li>其实是fc的一个特列，是<code>fc -l</code>命令的别名。在bash中，列出所有命令；在korn shell中，仅列出16条命令。经实验，在ubuntu linux中执行<code>fc -l</code>，显示16条；执行<code>history</code>，显示所有；</li>
<li><code>history 10</code>，列出最近执行的10条命令；</li>
<li><code>history -c</code>，清除命令历史缓冲区中的命令。</li>
</ol>
</li>
<li>重复执行先前命令的方式<ol>
<li>在bash中，执行<code>$ !!</code>；</li>
<li>常用的部分”!”命令，自行查阅。</li>
</ol>
</li>
</ol>
</li>
<li>命令的别名（略）</li>
<li>作业控制<ol>
<li>在bash中，set命令的”-m”或”-o monitor”选项用于启用shell的作业控制功能。</li>
<li>除了进程ID之外，shell还会为每个作业分配一个数字较小的作业号。例如，利用”&amp;”符号启动后台作业，并使之异步运行，shell将会输出如下信息。<blockquote>
<p><code>$ find / -name &quot;*conf&quot; -print &gt; conf.log 2&gt;&amp;1 &amp;</code><br><br><code>[1] 2136</code>，<code>[1]</code>作业号，<code>2136</code>作业的进程ID。</p>
</blockquote>
</li>
<li><span class="red-back"> shell 采用作业控制表记录和跟踪当前的作业</span>。利用<code>jobs</code>内部命令，可以显示作业控制表中保存的当前作业。</li>
<li>linux中的作业有运行running，停止stopping，退出exited，完成finished等状态。<blockquote>
<p><code>$ bg %1(作业号)</code>，把停止运行的作业放到后台运行；<br><br><code>$ fg %2</code>，让一个后台作业回到前台继续运行； <br><br><code>kill %1</code>，停止后台作业 <code>wait %2</code>，等待当前正在运行的作业完成。</p>
</blockquote>
</li>
</ol>
</li>
<li>会话记录与命令确认<ol>
<li>保存会话记录：在linux中提供了<code>script</code>命令，可以记录用户从注册到推出系统的整个或部分会话过程，包括用户的输入和系统的响应信息。例如：<blockquote>
<p>$ script，在当前目录自动产生typescript文件<br><br>script started，file is typescript<br><br>$ ….，用户操作<br><br>$ exit<br><br>exit<br><br>script done, file is typescript<br><br>$ cat typescript，显示用户相关操作信息<br></p>
</blockquote>
</li>
<li><span class="red-back">确保使用命令的正确性</span><ol>
<li><code>which</code>：区分同名指令，如tar命令，如何知道是用的哪个tar命令，<code>$ which tar</code>，显示<code>/bin/tar</code>；</li>
<li><code>whereis</code>，显示所有与给定命令相关的文件，如$ <code>whereis tar</code>，显示<code>tar:/bin/tar /usr/lib/tar /usr/include/tar.h /usr/share/man/man1/tar.1.gz</code>。</li>
<li>通过<code>apropos</code>命令，模糊查找给定命令在文档中的说明；<code>whatis</code>命令，完全匹配给定的关键字命令。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="三、文件系统"><a href="#三、文件系统" class="headerlink" title="三、文件系统"></a>三、文件系统</h1><ol>
<li>路径名称规则<ol>
<li>如果路径名以”/“开头，则说明该路径名是从根目录开始的<strong>绝对路径名</strong>，除此之外，其他所有的路径名都是相对于当前目录的<strong>相对路径名</strong>；</li>
<li>路径名要么是单个名字，或者是以”/“分隔的多个名字，最后一个是文件，可以是任何类型；</li>
<li>在任何目录位置，在路径名中使用”..”，可以往上攀升系统的目录层次。</li>
</ol>
</li>
<li><p>树形层次结构</p>
<ol>
<li><code>-/</code><br></li>
<li><code>--/bin</code>，<span class="red-back">其中包含系统、系统管理员和普通用户可以共享的各种通用程序，如cat、cp、mv、mkdir、rm、ls及ps等常用的基本命令，以及如bash等的各种shell。</span><br></li>
<li><code>--/boot</code>，其中包含系统引导程序、linux内核程序文件vmlinuz、磁盘内存印象文件initrd以及GRUB初始引导程序和配置文件等。<br></li>
<li><code>--/dev</code>，在linux系统中，任何设备均对应一个或多个特殊文件（或称为设备文件），这个目录包含了系统支持的所有设备文件。例如：console表示控制台，lp0表示打印机。<br><blockquote>
<p><code>----/mem</code>，表示系统的物理内存。<br><br><code>----/sda</code>，sda表示连接到主控制器的第一个磁盘，sda1或sda2等则分别表示其中的第一个和第二个磁盘分区等。<br><br><code>----/...</code>，其他相关，这里略。<br><br><code>----/tty</code>，表示系统的串口设备。<br></p>
</blockquote>
</li>
<li><code>--/etc</code>，<span class="red-back">该目录是整个linux系统的中心，其中包含所有系统管理和维护方面的配置文件，如host.conf，syslog.conf和vsftpd.conf等。</span><br><blockquote>
<p><code>----/apache2</code>，apache配置文件的根目录，其中包含apache服务器的各种配置文件，如apache2.conf等。<br><br><code>----/apt</code>，<span class="red-back">其中包含了软件管理工具使用的配置文件，如sources.list等。</span><br><br><code>----/cron.d</code>，用于存储cron进程调度运行后台进程所用的配置和控制文件。<br><br><code>----/init.d</code>，用于存储系统启动过程中需要有init调度执行的脚本文件。<br><br><code>----/mysql</code>，<span class="red-back">其中包含MySQL数据库的配置文件，如my.cnf等。</span><br><br><code>----/network</code>，其中包含网络接口的配置文件interfaces，以及相关的配置工具。<br><br><code>----/...</code><br><br><code>----/ssh</code>，<span class="red-back">OpenSHH网络服务所在配置和控制文件的根目录，其中含有sshd_config等重要配置文件。</span><br></p>
</blockquote>
</li>
<li><code>--/home</code>，<span class="green-back">用户主目录的根目录。新增一个用户，系统将会在/home目录中创建一个形如/home/$USER的子目录，作为用户的目录，其中的$USER为用户名。也可以作为<em>单独的文件系统</em>。</span><br></li>
<li><code>--/lib</code>，该目录含有系统引导过程，以及运行系统命令所需要的内核模块和各种动态链接共享库文件（扩展名为.so，相当于windows系统中的.dll文件）。其中，内核模块（驱动程序）位于/lib/modules/kernel-version子目录中。<br></li>
<li><code>--/lost+found</code>，每个文件系统分区都存在一个lost+found目录，用于存储fsck命令在检测与修复文件系统时删除的文件或目录。<br></li>
<li><code>--/media</code>，移动存储介质的安装点，当利用GNOME界面安装移动存储介质时，系统将会自动地把移动介质安装到此目录下的某个子目录中。<br></li>
<li><code>--/mnt</code>，文件系统的临时安装点。<br></li>
<li><code>--/opt</code>，应用程序等附加软件的安装目录。<br></li>
<li><p><code>--/proc</code>，进程文件系统proc的根目录，其中的部分文件分别对应当前正在运行的进程，可用于访问当前进程的地址空间。<br></p>
<blockquote>
<p><code>----/net</code>，其中的文件分别表示各种网络协议（如tcp，udp及arp等）的状态与统计信息。<br></p>
</blockquote>
</li>
<li><code>--/root</code>，<span class="red-back">超级用户root的主目录（在linux系统中，”/“是整个系统的根目录，而非超级用户的主目录）</span><br></li>
<li><code>--/sbin</code>，该目录中的命令主要供超级用户使用，普通用户通常无法使用。其中包含与系统引导、管理维护，以及与硬件配置等方面有关的命令和脚本文件，符fdisk、init和ifconfig等。<br></li>
<li><code>--/tmp</code>，临时文件目录，用于存储系统运行过程中生成的临时文件，也可以用户存储自己的临时文件。一般不要自己删除这个目录中的文件。<br></li>
<li><code>--/usr</code>，<span class="green-back">既可以作为一个<em>单独的文件系统</em>，也可以作为根目录下的一个子目录，其中存有系统提供的各种共享数据（如用户命令、库函数、头文件和文档等）</span><br><blockquote>
<p><code>----/include</code>，用于存储各种c语言文件。是c开发人员需要经常引用的文件。<br><code>----/bin</code>，其中包含用户经常使用的各种命令(find,make,…,who)<br><br><code>----/lib</code>，包含各种共享的库函数，可供程序员以静态或动态链接自己开发的应用程序。<br><br><code>----/sbin</code><br><br><code>----/share</code><br><br><code>----/src</code>，用于存放linux系统内核的源代码和文档等。<br></p>
</blockquote>
</li>
<li><code>--/var</code>，<span class="green-back">既可作为一个 <em>单独的文件系统</em>，也可作为根目录下的一个子目录，用于存储各种可变长的数据文件（如日志文件）、暂存文件或待处理的临时文件等。</span><br><blockquote>
<p><code>----/lib</code>，用于存储软件包特定的动态链接共享库、配置文件和状态信息等。<br><code>----/lock</code><br><code>----/log</code>，用于守护进程日志文件的存储目录<br><br><code>----/mail</code><br><br><code>----/run</code><br><br><code>----/spool</code>，用于缓存各种待处理的文件。<br><br><code>----/tmp</code>，用于存储各种临时文件。<br><br><code>----/www</code>，<span class="red-back">apache服务器的用户文档根目录，用于存储和发布各种HTML文档。</span></p>
</blockquote>
</li>
</ol>
</li>
<li>文件的类型<ol>
<li>普通文件</li>
<li>目录文件<ol>
<li><code>$ pwd</code>，查看当前所处的目录；</li>
<li><code>$ mkdir dirname</code>，创建一个目录；</li>
<li><code>$ rmdir dirname</code>，删除一个目录。</li>
</ol>
</li>
<li>特殊文件：也称设备文件，linux系统利用特殊文件作为用户与I/O设备之间的接口，使用户能够像读写普通文件一样访问外部设备。</li>
<li>链接文件</li>
<li>符号链接文件</li>
<li>管道文件</li>
</ol>
</li>
<li><p><span class="red-back">文件保护机制</span></p>
<ol>
<li>linux系统把用户分为三类：<ol>
<li>文件属主</li>
<li>同组用户</li>
<li>其他用户</li>
</ol>
</li>
<li>文件的三种基本访问权限<ol>
<li>r（读）：如果文件具有读许可，则相应的用户额可以读文件，如显示文件内容、复制文件等，但不能修改文件。如果允许用户进入某个目录，列举目录下的文件，则至少应赋予用户“读”目录的访问权限；</li>
<li>w（写）:如果文件具有写许可，则相应的用户可以读、写文件，包括显示文件内容以及复制、修改、移动和删除文件等。对于目录而言，如果允许用户创建新文件和删除文件，则必须赋予用户“写”目录的访问权限；</li>
<li>x（执行）：如果具有执行许可，则相应的用户可以运行文件（如程序文件）。对于目录而言，如果允许用户访问其中的任何子目录，则必须赋予用户“执行”目录的访问权限。</li>
</ol>
</li>
<li>举例<blockquote>
<p><code>$ ls -l /bin</code>，查看对bin目录的访问权限<br><br><code>drwxr-xr-x 2 root root 4096 5月 9 05：47 /bin</code><br><br>d表示文件类型为目录，rwx r-x r-x表示文件属主的访问权限为rwx、同组用户的访问权限为r-x、其他用户的访问权限为r-x。</p>
</blockquote>
</li>
<li><p><span class="red-back">修改文件的访问权限</span></p>
<ol>
<li>前提条件<ol>
<li>用户必须是文件或目录的属主</li>
<li>或超级用户</li>
</ol>
</li>
<li>chmod用法示例<ol>
<li>相对权限设置法：<blockquote>
<p>格式<code>$ chmod permissions dir-or-file</code> <br><br><span class="red-back">用字符表示用户类型：u（文件属主），g（同组用户），o（其他用户），a(所有用户)</span>；<br><br>“+”或”-“表示增加或撤销相应的权限；<br><br><code>$ chmod o+w script</code>，表示对其他用户添加写权限<br><br><code>$ chmod o-rw script</code>，表示对其他用户撤销读写权限。</p>
</blockquote>
</li>
<li>绝对权限设置法<blockquote>
<p>格式<code>$ chmod numcode dir-or-file</code>，numcode是一个数字代码，用于表示文件的访问权限，由3位数字组成，分别对应于文件属主、同组用户和其他用户。<br><br><code>$ chmod 755 file</code>，表示对属主用户设定权限码为7，同组用户权限码为5，其他用户权限码为5。<br><br><span class="red-back">“r”对应的二进制码为100（4）,”w”对应的二进制码为010（2），”x”对应的二进制为001。其中，rwx构成的某一用户的权限码是8进制的。</span>。<br><br>解读755，7=4+2+1（rwx），5=4+0+1（r-x），5=4+0+1（r-x）。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>其他访问权限设置</p>
<ol>
<li><p>默认权限：无论何时创建一个文件，linux系统通常会为用户设置一个默认的访问权限。用<span class="red-back">umask</span>命令。</p>
<blockquote>
<p>格式，<code>umask [-S] [nnn]</code>，这个[nnn]与chmod命令中的numcode相反，在对应位上设置1，即为撤销该权限。如000 000 000，设置为000 010 010，即为022，表示u有rwx权限，g有r-x权限，o有r-x权限。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="四、文件和目录操作"><a href="#四、文件和目录操作" class="headerlink" title="四、文件和目录操作"></a>四、文件和目录操作</h1><ol>
<li><p><strong>创建文件</strong></p>
<p> <code>$ touch emptyfile</code>，当前目录下，要是没有该文件，就自动创建一个，有则不产生作用；<br><br> <code>$ &gt; emptyfile</code>，利用重定向，产生的文件将覆盖已有的同名文件；<br><br> <code>$ echo &quot;hello word!&quot; &gt; newfile</code>，创建一个含有内容为”hello world”的新文件；<br><br> <code>$ cat &gt; myfile</code>，通过终端输入内容，创建并写入myfile文件；<br><br> 还可以通过vim编辑器，在terminal里面进行操作。</p>
</li>
</ol>
<ol start="2">
<li><p><strong>显示文件列表</strong></p>
<ol>
<li>使用<code>ls</code>命令：ls [options] [dir or file]</li>
<li><p>几个常用的参数：<code>ls -a</code>，列出当前目录下的所有文件（包括.*隐藏文件）;<code>ls -d</code>如果指定的参数是目录，只显示目录的名字，而不是列出目录下的文件；<code>ls -l</code>，这个经常使用，以每行一个文件的长格式列出文件的类型、访问权限、链接数、用户属主、用户组、文件大小、最后修改时间和文件名等；<code>ls -r</code>，以文件名反向排序显示文件列表（–reverse）；<code>ls -R</code>，注意区分与<code>r</code>的区别(–recursive)，递归显示目录及子目录下的所有文件；<code>ls -s</code>，显示分配给文件的数据块，因此，当文件大小相近时，它们的数据块可能是一样的。</p>
<blockquote>
<p><strong> 示例：</strong><br></p>
<ol>
<li>列出当前目录下的文件，<code>ls</code><br></li>
<li>列出指定目录下的文件，<code>ls /</code><br></li>
<li>利用通配符显示文件，如<code>ls -l *.c</code>，<code>*</code>匹配多个字符，列出当前目录下以c结尾的所有文件，为了避免列出子目录中的文件，可以使用<code>ls -ld *</code><br></li>
</ol>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>显示文件内容</strong></p>
<ol>
<li><code>cat [options] [file]</code>，将文件中的内容全部显示到终端，若内容太多，只能看到最后部分；</li>
<li><code>more [options] [file]</code>，将从头到尾一页一页地仔细阅读文件。如果文件很长，在左下角会出现<code>--More--(n%)</code>，<code>（n%）</code>表示已显示的数据内容占整个文件的百分比。<code>less</code>命令的功能与<code>more</code>类似且比它强大；</li>
<li><code>head [-number | -n number] [file]</code>，number表示需要输出的行数。默认，输出前10行（包括空行）；</li>
<li><code>tail [+/-number [-lbcf]] [file]</code>，<code>+</code>表示从文件的其实位置开始计算，<code>-</code>表示从文件的结束位置开始计算。number表示要输出的行数。<strong>备注</strong>：<code>tail</code>，只能访问静态文件的最后几行，对于内容动态增长的文件如日志文件，需要这样访问，<code>tail -f somelogfile</code>。也就是说，somelogfile文件内容加一行，终端就显示一行，实时的。</li>
</ol>
</li>
<li><p><strong>复制文件</strong></p>
</li>
<li><p><code>cp [-ir] source_file target_file</code>，其中，<code>-i</code>表示交互复制方式。例如，要将src文件拷贝到target文件时，如果target文件存在，则给出提示信息，是否要覆盖已有的文件。<code>-r</code>表示递归操作，就是如果src是目录文件，则将目录中的子目录递归复制，拷贝到目标文件中。</p>
</li>
<li><p><strong>移动文件</strong></p>
</li>
<li><p><code>mv [-fi] source_file target_file</code>，把文件从一个目录移动到另外一个目录中，或者重新命名一个文件。<code>-f</code>表示强制移动或改名（force），<code>-i</code>用于交互，给出目标文件存在时的提示信息。</p>
</li>
<li><p><strong>删除文件</strong></p>
</li>
<li><p><code>rm [-rfi] [file]</code>，<code>-r</code>表示递归地删除目录中的文件及目录本身；<code>-i</code>表示交互操作，询问是否真的要删除；<code>-f</code>表示强制删除，即使不存在该文件，也不会输出任何信息。</p>
</li>
<li><p><strong>改换目录</strong></p>
<ol>
<li>在linux系统，每个用户都有一个属于自己的主目录。在注册之后，系统将会自动地把用户引导至自己的主目录；</li>
<li>在bash、korn shell等shell中，<code>~</code>表示用户主目录缩写，在bourne shell中，停替代方法是引用<code>$HOME</code>。</li>
</ol>
</li>
<li><p><strong>创建、移动和复制目录</strong></p>
<ol>
<li><code>mkdir src</code></li>
<li><code>mv src</code></li>
<li><code>cp -r dir1 dir2</code></li>
</ol>
</li>
<li><p><strong>删除目录</strong></p>
<ol>
<li>指令模版，<code>rmdir [-p] directory</code>；</li>
<li>删除一个空的目录，其指令为<code>rmdir dir1</code>；</li>
<li>删除一个非空目录，需要添加<code>-r</code>参数选项,意思是recursive递归，即<code>rm -r dir1</code>，可以把指定目录及其任何子目录中的所有文件全部删除。</li>
</ol>
</li>
<li><p><strong>比较文件之间的差别</strong></p>
<ol>
<li>当面对两个类似的文件，想找出其中的细微差别时，可以使用diff命令比较，<code>diff file1 file2</code></li>
<li>比较三个文件的不同，可以使用<code>diff3 file1 file2 file3</code>。</li>
</ol>
</li>
<li><p><strong>从系统中检索文件</strong></p>
<ol>
<li><code>find directory [options]</code><ol>
<li>find命令将按用户指定的检索条件，从指定的目录开始，找出满足匹配准则的所有文件。指定的检索条件可以是文件（包括通配符）、文件大小及文件修改日期等。</li>
<li>其中，directory是检索的起始目录，options是一种表达式选项，用于指定各种匹配准则或检索条件。</li>
<li>find命令的部分常用选项，自查。</li>
</ol>
</li>
<li><hr>
</li>
<li><hr>
</li>
</ol>
</li>
<li><p><strong>检索文件内容</strong></p>
<ol>
<li><p>利用grep检索文件内容</p>
<ol>
<li>检索文件中的特定字符串，<code>grep [-inv] string file</code>，其中，<code>-i</code>表示忽略字母大小写，<code>-n</code>表示在输出结果之前给出文本行所在文件中的行号，<code>-v</code>表示检索不包含个i定字符串或模式的所有文本行。<code>string</code>是一个检索模式。检索模式可以是一个准备检索的字符串、一个单词或词语。</li>
</ol>
</li>
<li>在grep中使用正则表达式<ol>
<li>在grep中可使用简单的正则表示，复杂的模式匹配需要使用egrep；</li>
</ol>
</li>
<li><hr>
</li>
</ol>
</li>
<li><p>排序</p>
<ol>
<li><code>sort [-bdfimnru] -k key -t sepchar -o output [file]</code>，可对输入的数据或文件内容进行排序。其中，<code>-n</code>按照字符串数值进行排序，<code>-r</code>表示按照从大到小或反向顺序排序，<code>-k</code>表示关键字的字段位置或关键字字段起止字符位置或范围，<code>-b</code>表示忽略前置的空白字符，<code>-d</code>表示仅考虑字母数字和空格字符，按照字典顺序排序；</li>
<li>使用示例：<blockquote>
<p><code>ls -l /var/log/syslog*</code>，该指令是显示所有系统日志的，显示的部分结果如下：<br><br><code>-rw-r----- 1 syslog adm 552   6月 8 15：17 syslog</code> <br><br><code>-rw-r----- 1 syslog adm 103381 6月 8 13：30 syslog.1</code> <br><br><code>...</code><br><br>现在需要根据文件的大小降序排列，具体指令如下：<br><br><code>ls -l /var/log/syslog* | sort -rn -k5</code><br><br><code>-rw-r----- 1 syslog adm 103381 6月 8 13：30 syslog.1</code> <br><br><code>-rw-r----- 1 syslog adm 552   6月 8 15：17 syslog</code> <br><br><code>...</code><br><br>其中，-r表示降序排序，-n表示按照数值大小，-k按照第5个关键字字段位置（也就是文件的大小），实现最终的排序。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h1 id="五、编辑文件（vim）"><a href="#五、编辑文件（vim）" class="headerlink" title="五、编辑文件（vim）"></a>五、编辑文件（<a href="http://www.vim.org" target="_blank" rel="noopener">vim</a>）</h1><ol>
<li><p><strong>vim来源</strong>：vim是对unix系统上vi编辑器的扩充与增强，提供许多附加的功能特性，与vi几乎完全兼容。可运行在windows、Macintosh、Unix和Linux系统上。</p>
</li>
<li><p><strong>启动vim</strong></p>
<ol>
<li><code>$ vim myfile</code>，若myfile存在，则会打开指定的文件，并显示文件第一页的内容。若文件不存在，vim将会打开一个新文件；</li>
<li>进入vim编辑器界面之后，屏幕左边的波浪符”~”表示空行；</li>
<li>vim可以同时编辑多个文件，也可以不指定文件名，等到完成文件再写入新文件，然后退出；</li>
<li>直接输入<code>vim</code>命令而未指定文件的名字，会显示vim的介绍信息。此时，可以直接进入插入模式（输入i），编写文件，然后保存（:w filename），退出（:q）。如果想放弃保存当前的操作，则可以强制退出（：qa!）。具体可同:help查看帮助；</li>
<li>状态行：编辑窗口的最后一行是vim的状态行，用于显示编辑器的状态、编辑过程中出现的错误信息、光标所在的行列位置、删除或复制的行数等。初始启动时，状态行会显示文件的名字、行数和字节数。</li>
</ol>
</li>
<li><p><strong>vim编辑器的工作模式</strong></p>
<ol>
<li>命令模式：按下<code>esc</code>键，总是进入命令模式；</li>
<li>输入模式：在要输入文本之前，输入i或a进入输入模式，然后esc，返回命令模式，执行保存退出；</li>
<li>输入”:”开始执行命令的时候</li>
</ol>
</li>
<li><p><strong>保存编辑文件并退出vim</strong></p>
<ol>
<li>注意随时保存数据，特别是当编辑重要的文件时，vim编辑器提供了许多命令，用于把内存缓冲区中的数据内容保存到磁盘文件中，然后退出vim。如”保存并退出”、”强制退出并不保存”等；</li>
<li><strong>相关命令</strong><ol>
<li><code>:w</code>，保存编辑后的文件内容，但不退出vim编辑器。把内存缓冲区中的数据写到启动vim时指定的文件中</li>
<li><code>:w!</code>，强制写文件，即强制覆盖原有的文件。如果原文件是只读文件，并且当前用户是该文件的属主，则可以强制写入；</li>
<li><code>:wq</code>，保存文件内容后退出vim编辑器。写入并退出。另一个替代指令为<code>ZZ</code>；</li>
<li><code>：wq!</code>，强制保存文件内容后退出；</li>
<li><code>ZZ</code>，如果文件已经做过编辑处理，则把内存缓冲区中的数据强制写到启动vim时指定的文件中，然后退出。否则只是退出而已；</li>
<li><code>:q</code>，在未做任何编辑处理而准备退出vim时，使用；</li>
<li><code>:q!</code>，强制退出vim编辑器，放弃编辑处理的结果。如果确实不需要保存修改后的文件内容，可输入该命令，强制退出；</li>
<li><code>:w filename</code>，把编辑处理后的结果写到指定的文件中保存；</li>
<li><code>:w! filename</code>，把编辑处理后的结果强制保存在指定的文件中，如果文件已经存在，则覆盖现有的文件；</li>
<li><code>:wq! filename</code>，把编辑处理后的结果强制保存在指定的文件中，如果文件已经存在，则覆盖现有的文件，最后退出；</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>vim编辑器基本命令</strong></p>
<ol>
<li>移动光标位置：</li>
<li>输入文本：<ol>
<li><code>a</code>，可在当前光标所在字符位置之后输入数据；</li>
<li><code>A</code>，可在光标当前所在行的行尾输入数据；</li>
<li><code>i</code>，可在光标当前所在字符位置之前输入数据；</li>
<li><code>I</code>，可在当前光标所在行的行首输入数据；</li>
<li><code>o</code>，可在光标所在行的下一行新起，输入数据；</li>
<li><code>O</code>，可在光标所在行的上一行新起，输入数据。</li>
</ol>
</li>
<li>修改和替换文本<ol>
<li><code>C</code>，替换从光标位置<strong>开始直至行尾</strong>的所有数据内容，然后输入数据；</li>
<li><code>cw</code>，替换单个字。如”hello world”，光标在hello的h上，输入cw，会取代hello(以空格分隔，一个单词为一个字)，输入新的字替换，而不会去掉world；</li>
<li><code>[n]cc</code>，cc命令，指将光标所在行，全部去掉，输入新数据；加上n后，表示要替换的行数，从光标所在位置，往下替换掉n行；</li>
<li><code>[n]s</code>，表示替换字符，s表示替换光标所在位置的字符，n表示从光标开始往后的n个字符要被替换；</li>
<li><code>S</code>，替换当前光标所在的行；类似cc；</li>
<li><code>r</code>，替换单个字符，类似与1s。<strong>唯一不同的是，r执行完后，自动返回命令模式</strong>;</li>
<li><code>R</code>，替换多个字符，可以从光标位置开始，替换多个字符，数量不限，直至按下esc；</li>
<li><code>[n]~</code>，转换光标当前所在位置字母的大小写，一直按<code>~</code>或者指定需要替换字母大小写的个数，可实现多个字母大小写转换。</li>
</ol>
</li>
<li>撤销先前的修改<ol>
<li><code>u</code>，用于撤销先前执行的编辑命令；</li>
<li><code>U</code>，用于撤销或回复最精一次的操作。</li>
</ol>
</li>
<li>删除文件（一直处于命令模式，而非输入模式（插入，取代））<ol>
<li><code>[n]x</code>，删除字符。n为要删除字符的个数，从光标所在位置的字符往后开始（相当于往后删除），<strong>包括当前光标所在位置</strong>；</li>
<li><code>[n]X</code>，删除字符。n为要删除字符的个数，从光标所在位置的字符往前开始（相当远往前删除），<strong>不包括当前光标所在位置</strong>；</li>
<li><code>dw</code>，删除单个字或部分字。删除整个字的话，包括其占用的空间位置，如字与字之间的分隔符；</li>
<li><code>[n]dd</code>，删除文本行。dd为删除当前光标所在行，n为删除多行；</li>
<li><code>D</code>，表示删除本行的行尾部分。</li>
</ol>
</li>
<li>复制、删除和粘贴文本<ol>
<li>复制-粘贴：先yy复制文本行，再用p（或P）实际复制，</li>
<li>剪切-粘贴：先dd删除文本行，再用p（或P）实现文本行的移动。</li>
<li>具体命令：<ol>
<li><code>[n]yy</code>，记住，<strong>该命令是复制文本行的，不是选中的部分</strong>，过程：<ol>
<li>把光标移至准备复制的文本行的任何位置；</li>
<li>输入<code>yy</code>命令；</li>
<li>再把光标移至目标行的任何位置；</li>
<li><code>p</code>，复制到所在行的<strong>下面</strong>，<code>P</code>，复制所在行的<strong>上面</strong>；</li>
<li>如果在yy前面输入n，可以复制多个文本行。</li>
</ol>
</li>
<li><code>[n]Y</code>，同yy；</li>
<li><code>[n]dd</code>，删除文本行。然后操作过程同yy类似；</li>
<li><strong>上面的指令必须结合p，P使用</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>按指定的数量重复执行指令<ol>
<li>许多vim命令前面都可以加一个计数值，表明相应的命令重复执行的次数；</li>
<li>使用<code>.</code>，可以重复执行先前的文本编辑命令；</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>使用ex命令</strong></p>
<ol>
<li>显示行号，<code>:set nu</code>，挺实用的！！！</li>
<li>取消行号，<code>:set nonu</code></li>
<li>多行复制，<code>:line#1，line#2 co line#3</code>，其中，<code>co</code>相当于copy<ol>
<li>例如，<code>:1,5 co 12</code>把第1行到第5行复制到第12行；</li>
<li>其中，<code>.</code>表示当前光标所在的行，<code>$</code>表示最后一行；</li>
</ol>
</li>
<li>移动文本，<code>:line#1, line#2 m line#3</code>，其中，<code>m</code>相当于move</li>
<li>删除文本，<code>:line#1, line#2 d</code></li>
</ol>
</li>
<li><p><strong>检索与替换</strong></p>
<ol>
<li>概述：使用户能够以检索指定字符串的方式，直接跳转至期望的文件位置。还提供全局检索和替换功能；</li>
<li>检索命令：<ol>
<li><code>:/str</code>，检索给定的字符；</li>
<li><code>:?str</code>，从当前位置开始，反向检索给定的字符串；</li>
<li><code>n</code>，从当前位置开始，继续检索下一个匹配的字符串；</li>
<li><code>N</code>，从当前位置开始，反向检索；</li>
<li><code>:/str/+n</code>，将光标移至匹配的字符串str所在行之后的第n行；</li>
<li><code>:?str?-n</code>，将光标移至匹配的字符串str所在行之前的第n行；</li>
</ol>
</li>
<li>模式检索<ol>
<li>仅检索出现在行首位置的字符串，<code>:/^search</code>；</li>
<li>仅检索出现在行尾位置，<code>:/search$</code>；</li>
<li>仅检索出现在字首位置的字符串，</li>
<li><hr>
</li>
</ol>
</li>
<li>替换字符串</li>
</ol>
</li>
<li><p><strong>编辑多个文件</strong></p>
<ol>
<li>编辑多个文件<ol>
<li><code>vim file1 file2</code>，先进入file1文件，编辑好后，<code>:w</code>保存；输入<code>:n</code>或<code>:n file2</code>，进入file2文件，编辑好后，输入<code>:w</code>保存。</li>
<li>可以使用<code>:e filename，:n filename</code>直接转到指定的文件，也可以使用<code>:n</code>命令转到下一个文件。<code>:n#</code>交替编辑最近处理过的两个文件。</li>
<li><code>:e! filename</code>，强行转到指定的文件。</li>
</ol>
</li>
<li>合并文件与合并文本行<ol>
<li><code>line# r filename</code>，将filename中的内容读到指定行line中；</li>
<li>如果未指定line，则默认是当前光标所在的行</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>定制vim编辑器的运行环境</strong></p>
<ol>
<li>vim编辑器采用一系列默认的选项定义作为自己的运行环境。为了提高编辑效率，需要改变部分选项的默认值。</li>
<li><code>:set all</code>，可以查看到所有的可设置选项，<code>:set option</code>，设置该选项，<code>:set nooption</code>取消该选项设置。</li>
<li>具体options如下：<blockquote>
<p>all，在编辑器窗口中列出编辑器支持的所有选项；<br><br>magic，设置magic，可启动字符的特殊意义，如”.”表示匹配任意一个字符；”[…]”表示匹配指定字符集和或字符范围中的任何一个字符。设置nomagic就会使特殊字符意义失效。<br><br>autoindent，这个选项与shiftwidth选项一起使用，使新输入的文本行与上一行起始位置自动对齐。<br><br>autowrite，自动保存，当打开多个文件的时候，当前编辑完成后，要切换到另一个文件，就会将当前文件自动保存；<br><br>ignorecase，字符串匹配时，可设置忽略大小写；<br><br>laststatus，是否在编辑窗口中显示状态行；<br><br>number，显示文本行的行号；<br><br>readonly，对正在编辑的文件进行写保护；<br><br>report，默认值为2，表示复制或删除了多少行，在状态栏中报告；<br><br>scroll，设置前滚（ctrl+U）多少行，后滚(ctrl+D)多少行，如:set scroll=10;<br><br>shell，确定vim调用哪一个shell，如:set shell=path，path为shell的绝对路径；<br><br>shiftwidth，这个选项用于设定制表符的跳转位置，按下<strong>ctrl+t或ctrl+d</strong>，自动跳转到下一个或上一个制表符位置，默认为8；<br><br>showmatch，输入右圆括号、花括号或方括号时，提示与左边的括号相匹配；<br><br>tabstop，设置制表键tab的右移距离。默认为8；<br><br>wrap，控制vim显示较长的文本行。把较长的文本行延续到下一行，可利用该选项实现自动折行；<br><br>wrapmargin，指定编辑器窗口的右边距；</p>
</blockquote>
</li>
<li>永久性定制vim运行环境<ol>
<li>上面的方法都只能临时地设置vim编辑器的当前运行环境，一旦退出，这种临时设置也随之作废；</li>
<li>永久性设置<ol>
<li>需要设置<strong>VIMINTI变量</strong>。在.bash_profile中添加export VIMINTI = ‘set para1 para2 …’；</li>
<li>也可以把常用的vim选项以及定义加到系统范围的初始化文件<code>/etc/vim/vimrc</code>文件，或用户主目录下的.vimrc(或.exrc) 文件中，可以自己在用户主目录下建立.vimrc文件，在里面写入<code>ab abc 中国农业银行</code>，等</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>其他特殊说明</strong></p>
<ol>
<li>删除或替换特殊字符</li>
<li>在编辑期间运行linux命令<ol>
<li><code>:sh</code>，在vim编辑器中，要转到执行shell的命令话，可使用该命令。此时，使用ctrl+d或exit命令，可退回到vim编辑，继续刚才文件的编辑；</li>
<li><code>:!command</code>，在编辑期间，如果想临时地运行某一个shell命令，可使用该命令，执行完毕后，按enter，即可回复原来的编辑处理状态；</li>
<li><code>!!command</code>，在编辑期间，如果想把某个shell命令的运行结果直接加到当前编辑的文件中</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="六、Shell"><a href="#六、Shell" class="headerlink" title="六、Shell"></a>六、Shell</h1><ol>
<li>基础知识</li>
<li>高级编程</li>
</ol>
<h1 id="七、软件管理"><a href="#七、软件管理" class="headerlink" title="七、软件管理"></a>七、软件管理</h1><ol>
<li><p><strong>软件维护工具</strong></p>
<ol>
<li><strong>命令行</strong>的软件维护工具，包括<code>apt-get</code>、<code>aptitude</code>以及<code>dpkg</code>等；</li>
<li><strong>图形界面</strong>的软件维护工具，包括<code>gnome-app-install</code>与<code>snaptic</code>。</li>
</ol>
</li>
<li><p><strong>软件管理</strong></p>
<ol>
<li>软件包：在ubuntu Linux系统中，所有的软件和文档都是以软件包档案文件的形式提供的。软件包可分为<strong>二进制软件包</strong>（用于封装可执行程序、相关文档以及配置文件等）和源代码软件包（包含源代码以及生成二进制软件包的制作方法）；</li>
<li>常见的软件包的格式：<ol>
<li><strong>Debian</strong>格式软件包（.deb）:<strong>ubuntu软件仓储中提供的软件包均采用这种封装格式</strong>，<strong>apt-get、aptitude和synaptic都支持此类软件包</strong>；</li>
<li><strong>Red Hat</strong>格式软件包（.rpm）:RPM（Red hat Package Manager）是另外一种流行的Linux系统软件包，是Red hat以及派生（如fedora）支持的；</li>
<li><strong>Tarball</strong>:一种由大量文件（包括目录结构）组装成单个档案文件的大型文件集合。其中<code>tar</code>命令用于组合多个文件，生成一个文档，以便于发行；<code>gzip</code>用于压缩文件的容量，以便节省文件的存储空间。Tarball非常类似于windows的”.zip”文件。Tarball文件具有<code>.tar.gz</code>，<code>.tar.bz2</code>或<code>TGZ</code>形式的文件扩展名。<strong>在命令行终端窗口，可以使用</strong><code>tar -xzf filename</code><strong>来解压相应的文件，然后在执行其中包含的软件安装命令</strong>。</li>
</ol>
</li>
<li>软件仓库:指的是一个网站或存储目录，其中提供按一定组织形式存储的软件包与索引文件。</li>
</ol>
</li>
<li><p><strong>利用apt-get管理软件包</strong></p>
<ol>
<li>APT（advanced package tool）:<strong>一个通用的综合软件管理与维护工具，apt-get、aptitude和synaptic等软件工具包都是基于APT及其配置文件发展而来，是APT的前端软件管理工具</strong>。</li>
<li>早期，APT配置命令都存储在单独的配置文件中<strong>/etc/apt/apt.conf</strong>中。在ubuntu linux中，把这个文件分解成多个小型文件，存储在<strong>/etc/apt/apt.conf.d</strong>目录中。<strong>/var/lib/apt/lists</strong>目录存有APT本地软件包索引文件。<strong>/var/cache/apt/archives</strong>目录是APT的本地缓冲目录，其中缓存了最近下载的deb软件包文件。</li>
<li>APT将采用<strong>/etc/apt/sources.list</strong>和<strong>/etc/apt/apt.conf.d目录中所有文件</strong>作为配置文件。</li>
<li>apt-get是一个命令行软件管理工具，能够利用软件仓库安装选定的软件包，或者删除、更新系统中已经安装的软件包，升级linux系统。具体的使用命令为：<code>apt-get [-hvs] [-o=config string] [-c file] {[update] | [upgrade] | [dselect-upgrade] | [install pkgs] | [remove pkgs] | [purge pkgs] | [check] | [clean] | [autoclean] | [autoremove]}</code>，其中，apt-get命令支持的部分功能选项，自查。</li>
<li><strong>常见使用</strong><ol>
<li><code>sudo apt-get install packagename</code>，安装指定的软件包；</li>
<li><code>sudo apt-get update</code>，用于同步软件源的软件包索引，获取最新的可用软件包版本信息；<code>sudo apt-get upgrade</code>，用于升级整个Ubuntu Linux系统（升级的过程，就是软件包的删除和重装过程）；</li>
<li><code>sudo apt-get remove/purge packagename</code>，用于删除软件包，其中remove属于部分删除，保留软件包中配置文件，而purge属于彻底删除；</li>
</ol>
</li>
<li><strong>sources.list配置文件</strong><ol>
<li>apt-get、aptitude以及synaptic是基于APT的，而ATP是使用<strong>/etc/apt/sources.list</strong>配置文件来定义软件的发行源的；</li>
<li>sources.list是主配置文件，可以在/etc/apt/sources.list.d目录中定义其他辅助配置文件，作为sources.list的补充；</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>利用aptitude管理软件包</strong></p>
<ol>
<li>aptitude是一个可以替代apt-get的软件管理工具，语法格式：<blockquote>
<p><code>aptitude [options] {updtae | autoclean | clean | safe-upgrade}</code> <br><br><code>aptitude [options] {install | reinstall | full-upgrade | download | purge | remove | show} pkgs</code> <br><br><code>aptitude [options] search patterns</code> <br><br><code>aptitude help</code></p>
</blockquote>
</li>
<li>常见使用<ol>
<li><code>sudo aptitude install package</code>，安装软件包；</li>
<li><code>sudo aptitude safe-update</code>同步软件源的软件包索引文件，<code>sudo aptitude safe-upgrade</code>升级整个系统；</li>
<li><code>aptitude show vsftpd</code>用于查询各种软件包信息；</li>
<li><code>aptitude search pkg-pattern</code>，用于检索软件包，可以检索系统中已经安装的软件包；</li>
<li><code>aptitude search ~T</code>，查询所有的软件包；</li>
<li><code>aptitude search ~U</code>，列出软件仓库中可供更新的软件包；</li>
<li><code>aptitude search ~i</code>，列出系统中已经安装的软件包，如aptitude search ‘-i apache’表示要检索系统中已经安装的apache服务器软件包；</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>synaptic图形界面软件管理工具</strong></p>
<ol>
<li>synaptic软件包管理器是一种基于APT开发的高级图形界面软件管理工具，其中实现了apt-get命令行工具的所有功能;</li>
<li>在命令行输入synaptic命令，启动；</li>
<li><hr>
</li>
</ol>
</li>
<li><p><strong>GNOME软件增删工具</strong></p>
<ol>
<li>是一种GNOME桌面菜单的软件管理工具，可以根据软件的功能或菜单分类，补充安装或删除选定的软件包，也可用于浏览、检索及查询软件包的说明信息；</li>
<li>在命令行，输入gnome-app-install启动；</li>
<li><hr>
</li>
</ol>
</li>
</ol>
<h1 id="八、用户管理"><a href="#八、用户管理" class="headerlink" title="八、用户管理"></a>八、用户管理</h1><ol>
<li><p><strong>相关概念</strong></p>
<ol>
<li>linux系统中的用户可以分为3类：<strong>超级用户</strong>(root)、<strong>管理用户</strong>和<strong>普通用户</strong>。但也可以把<strong>超级用户</strong>和<strong>管理用户</strong>通称为<strong>系统用户</strong>；<ol>
<li><strong>超级用户</strong>是一个特殊的用户，<strong>用户标识号为0</strong>，可以访问任何程序和文件，任何系统都会自动提供一个超级用户帐号；</li>
<li><strong>管理用户</strong>用于运行一定的系统服务程序，支持和维护相应的系统功能，<strong>用户标识号在1-999范围之内</strong>；</li>
<li>除了超级用户和管理用户，其他均为<strong>普通用户</strong>。访问linux系统的每个用户，都需要有一个用户帐号。只有利用用户名和密码注册到系统之后，才能够访问系统提供的资源和服务；</li>
</ol>
</li>
<li>Ubuntu linux系统强烈建议，应尽量避免使用超级用户注册到系统中，如果确实需要执行系统管理与维护任务，可以在具体的命令前冠以sudo命令；</li>
</ol>
</li>
<li><p><strong>/etc/passwd文件</strong></p>
<ol>
<li>安装linux系统之后，系统已经事先创建了若干系统用户帐号，其中包括超级用户root和管理用户daemon、bin和sys等，用于执行不同类型的系统管理和日常维护任务；</li>
<li>用户的帐号信息是有/etc/passwd和/etc/shadow文件共同维护的；</li>
<li>passwd文件中包含了linux系统中每个用户除密码之外的重要信息，每个用户信息占用一行，每一行由7个字段组成，中间以冒号分开：<code>username:password:uid:gid:comment:home_dir:login_shell</code><strong>(用户名:密码:用户id:用户组id:主目录:命令解释程序)</strong>，在passwd中部分内容如下：<blockquote>
<p><code>root:x:0:0:root:/root:/bin/bash</code> <br><br><code>daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</code> <br><br>…. <br><br><code>sucab:x:1000:1000:sucab,,,:/home/sucab:/bin/bash</code> <br><br>其中，每一个字段的具体说明如下：username:注册用户名，用户名在linux系统中必须是唯一的，且至少第一个字符选用字母；password为用户密码，但实际的密码已移至/etc/shadow文件中，如果用户设有密码，会显示为x，若显示*，则用户无法正常地注册到系统；uid用户id，是系统识别用户的主要手段，由系统或系统管理员分配，id为32为无符号整数，即为0-65536，其中0为超级用户，1-999为管理用户，1000-65536为普通的自定义用户；gid用户组id，系统中的每个用户均属于某个用户组，每个用户组除有组名之外，也有一个相应的用户组id，在0-999保留作系统用户组使用；comment为注释信息，包含用户全名，电话号码和电子邮件等用户信息；home_dir指定用户的主目录，环境变量${HOME}，形如/home/username；login_shell指定用户注册后调用的shell，即命令解释程序，如果该字段为空，则默认的命令解释程序为/bin/bash，用户可以根据自己的爱好，选用其他命令解释程序，如korn shell，zsh，tcsh等。</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>/etc/shadow文件</strong></p>
<ol>
<li>是一个限制访问的系统文件，其中存有加密形式的密码和其他相关信息，格式如下：<code>username:password:lastchanged:mindays:maxdays:warn:inactive:expire:reserve</code>，在shadow中的部分内容如下：<blockquote>
<p><code>root:!:16198:0:99999:7:::</code><br><br><code>daemon:*:16177:0:99999:7:::</code><br><br>…. <br><br><code>sucab:$6$En29/eVv$n1IaVG0PJ0x3QQtEoTDQU...FVYD.1:16198:0:99999:7:::</code><br><br>其中，password是加密形式的密码，通常用crypt(3)函数生成；lastchanged是从1970年1月1日开始算起，直至最后一次修改密码之日的天数；mindays保持密码稳定不变的最小天数，必须大于等于0，仅当超过此限才能修改密码；maxdays保持密码有效的最大天数，超过此限，系统将会强制提示用户更换新密码；warn指定在密码有效期到期之前需提前多少天向用户发出警告信息；</p>
</blockquote>
</li>
</ol>
</li>
<li><p><strong>增加、修改和删除用户</strong></p>
<ol>
<li>添加用户<ol>
<li><code>useradd [-u uid] [-g group] [-d home_dir] [-s shell] [-c comment] [-m [-k skel_dir]] [-N] [-f inactive] [-e expire] login</code></li>
<li>其中，login表示新用户的注册用户名；</li>
<li><code>-u uid</code>，（–uid uid），用于指定新增用户的用户id，是当前已经分配的最大id号加1；</li>
<li><code>-g group</code>，（–gid group），用于指定一个现有用户组的id或用户组名；</li>
<li><code>-N</code>，（–no-user-group），？</li>
<li><code>-d home_dir</code>，（–home home_dir），用于指定新增用户的主目录；</li>
<li><code>-s shell</code>，（–shell shell），用与指定命令解释程序shell的完整路径名。默认为/bin/bash</li>
<li><code>-c comment</code>，（–comment comment），用于指定用户全名、电话号码以及电子邮件地址等注释信息；</li>
<li><code>-m</code>，（–create-home），在增加新用户时，如果用户的主目录不存在，则创建用户主目录。同时，把/etc/skel目录或<code>-k</code>选项指定目录中的初始化文件复制到用户主目录中；</li>
<li><code>-k skel_dir</code>，（–skel skel_dir），用于指定存储用户初始化文件（.profile）的目录，以便useradd命令能够把其中的文件复制到用户主目录；</li>
<li><code>-f inactive</code>，（–inactive inactive），用于指定相应用户一直未访问系统，但仍保证其注册帐号信息有效的最多天数，超过此限将锁住用户帐号；</li>
<li><code>-e expire</code>，（–expiredate expire），指定注册用户的有效期，即截止日期；<blockquote>
<p><code>sudo useradd -u 1001 -d /home/sucab -m -s /bin/bash sucab</code> <br><br>系统将会在/etc/passwd、/etc/shadow、/etc/group文件中各添加一行与用户sucab相关的信息。一旦创建了用户帐号，就可以使用passwd命令设置密码，使用usermod等命令修改passwd和shadow文件，更改用户的其他相关属性</p>
</blockquote>
</li>
</ol>
</li>
<li>修改用户<ol>
<li>除非用户名或用户id与其他用户冲突，一般情况下不要轻易修改用户帐号中的用户名和用户id，因为这将涉及到用户已经创建的所有文件和目录。但commnet，shell，password，home_dir等可以修改；</li>
<li>修改用户信息时，可以利用编辑器，直接修改passwd和shadow，也可以使用usermode命令，自查。</li>
</ol>
</li>
<li>删除用户<ol>
<li>使用userdel命令，只需要一个命令即可删除passwd，shadow和group文件中的相应用户和用户组信息，同时还会把用户主目录中的所有文件和目录一同删除；</li>
<li><code>userdel [-r] login</code>，-r表示删除用户主目录，包括其中的文件和子目录。</li>
</ol>
</li>
<li>封锁用户帐号<ol>
<li>在/etc/shadow文件的密码字段增加一个感叹号”!”前缀；</li>
<li>在/etc/passwd文件的密码字段增加一个星号”*”；</li>
<li>修改shadow的expire字段为一个过时的日期。</li>
</ol>
</li>
<li>定期更改密码<ol>
<li>普通用户可以使用不带任何选项和参数的passwd命令修改自己的密码，使用实例如下：<blockquote>
<p><code>$ passwd</code><br><br> 更改 username 的密码。<br><br> （当前）unix密码：输入原密码 <br><br> 输入新的unix密码：输入新密码 <br><br> 重新输入新的unix密码:再输一次<br><br> 修改成功</p>
</blockquote>
</li>
<li><code>passwd [-adehlSu] [-i inactive] [-m min] [-m warn] [-x max] [login]</code>。超级用户则可以利用此命令的大量选项及参数维护系统中的用户帐号信息，passwd命令的部分选项自查，可以通过<code>$ passwd --help</code>，查看参数选项的作用，部分如下:<blockquote>
<p><code>-a</code>，只能与<code>-S</code>选项一起使用，以查询所有用户帐号的状态信息，必须具有超级用户权限，即<code>sudo passwd -aS</code>；<br><br><code>-d</code>，删除指定账户的密码；<br><br><code>-e</code>，强制指定账户密码过期；<br><br><code>-h</code>，显示此帮助信息并退出；<br><br><code>-l</code>，锁住指定的账户；<br><br><code>-S</code>，（–status），报告指定账户密码的状态；<br><br><code>-u</code>，(–unlock)，解锁被指定账户。<br><br>使用示例：<br><br><code>$ sudo passwd -S sucab</code><br><br><code>sucab P 05/08/2014 0 99999 7 -1</code>，其中，P表示用户sucab已经设置了密码；若为NP表示未设置密码，L表示账户已经锁住。</p>
</blockquote>
</li>
</ol>
</li>
<li>检验用户的有效用户ID<ol>
<li>要检查用户的有效用户ID，可以使用id命令。例如，当sucab注册到系统之后，id命令的输出结果如下：<blockquote>
<p><code>$ id</code> <br><br><code>uid=1000(sucab) gid=1000(sucab) 组=1000(sucab),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare)</code></p>
</blockquote>
</li>
<li>su命令<ol>
<li>su命令能够改变用户的有效用户ID，而不必另行注册；</li>
<li>使用示例(假设当前注册用户是sucab，另一个账户是zyt)：<blockquote>
<p><code>sucab@X-PC:~$ su zyt</code> （切换到zyt身份）<br><br>密码：输入zyt的密码 <br><br><code>zyt@X-PC:/home/sucab$</code>，说明，即使改变用户身份，仍会保持之前的工作目录不变；<br><br>如果，在su命令之后加上”-“、”-l”或”–login”，则可以直接进入其他用户的主目录，相当于zyt的直接登录。命令如下：<br><br><code>sucab@X-PC:~$ su --login zyt</code> <br><br>密码：输入zyt的密码<br><br><code>zyt@X-PC:~$</code><br><strong>5. 定制用户的工作环境</strong></p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li>相关概念：当用户注册到系统之后，用户的工作环境是由选定的命令解释程序和相应的用户初始化文件确定的。因此，<strong>用户管理的另一个任务是选择作为用户界面的命令解释程序和用户初始化文件。</strong></li>
<li><p>选择命令解释程序</p>
<ol>
<li>linux系统配备的标准命令解释程序是bash，但同时也支持korn shell(ksh)，基于C shell的TC shell（tcsh）以及Z shell（zsh）等，可以自由选用。</li>
<li><p>/etc/shells中列出了ubuntu linux系统支持的所有命令解释程序，下面介绍4个常见的：</p>
<ol>
<li><p><strong>Bourne Again Shell</strong></p>
<blockquote>
<p>bash是基于POSIX 1003.2标准开发的一个免费版的shell，与Bourne shell和korn shell一脉相承，在功能上有较大的提高。bash，支持emacs与vi两种命令行编辑功能，支持历史命令、命令别名和作业控制等机制。因此，Bash是linux系统首选的shell。</p>
</blockquote>
</li>
<li><p><strong>Korn shell</strong></p>
<blockquote>
<p>(/bin/ksh)是Unix系统中继Bourne shell与C shell之后推出的第3个著名的shell。Korn shell以Borne shell为基础，同时充分吸纳了C shell的优点，极大增强和丰富了Bourne Shell的基础功能。</p>
</blockquote>
</li>
<li><p><strong>TC shell</strong></p>
<blockquote>
<p>C shell原为BSD版unix系统的命令解释程序，由加州大学伯克利分校计算机系的Bill Joy开发。TC shell（/bin/tcsh）是在C shell的基础上开发的，继承并发展了C shell的全部功能特性。但与bash 和korn shell等Bourne系列的shell不兼容。</p>
</blockquote>
</li>
<li><p><strong>Z shell</strong></p>
<blockquote>
<p>同上述的shell一样，zsh既是一个交互式的命令解释程序，也是一个强有力的编程语言。zsh吸收并集成了bash、ksh以及tcsh等shell的许多功能特性，能够提高用户与linux系统交互的效率，非常适合用作交互式shell。zsh是上述shell的超集。</p>
</blockquote>
</li>
<li>任何时候，每个用户只能使用一个命令解释程序，但可以随时从一个shell切换到另一个shell环境。可以使用<code>ps -f</code>指令，找出ps的父进程，即可确定当前使用的哪一个shell。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<style type="text/css">
    .red-back {
        background:#D9534F;
        color:#FFF;
    }
    .green-back {
        background:#228B22;
        color:#FFF;
    }
</style>

</div><iframe src="/donate/?AliPayQR=/uploads/alipay.png&amp;WeChatQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://changbo.tech/blog/d563d963.html" data-id="cktlq5e6x00266nvxtddqp21q" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABwUlEQVR42u3aS27DMAwFwNz/0i7QVReN8kh9bASjlSE41igLQiT1esXj+h1/n/OZZH7xwMXFneZew1F9590Gqtt4uyVcXNyD3CR4vVs4+VUS+MYGXFzcZ3Lzo8n4HVxc3O/jjg8lM0ccXFzcp3GriU0SmG7O1XBxcSe4vYLp2uft9V1cXNxFXYk8tFWDUXNdXFzcI9xq+aNXFhknNuVCKi4u7mZuNV2ptlLG83lqhIuLexe310rpbbi5eVxc3IPcapukR8lDWyFXw8XF3cBNXt3Rjq1yC8VTXFzcae7MMtVW60yihYuLe5KbJx69KxG9Sxsf6Li4uJu5eWLT69IUkplkXVxc3IPcVVGiVzQptHZwcXFv5c4kMHkyk5ddcHFxT3ILVx+KX6j+NeVECxcXdxs3b6PmG8tnkg1EPWFcXNyl3Gq5My+tFlojrWIrLi7uPu5VHDPhqdee+XDEwcXF3cCdj4LNpkgc/nBxce/iJsFr5nCTXMMqXNLCxcU9yJ1Jfo6WX3FxcR/JnW+y5l/GxcV9PrfaWO0lOVE3GBcX9wi3mvzkSct42wsuYeDi4m7griqYJsGuGvI21ndxcXH/5/4AenD8M20bht8AAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/linux/">linux</a></div><div class="post-nav"><a class="pre" href="/blog/fa1b3b3e.html">我的书单</a><a class="next" href="/blog/d0befed5.html">Hadoop Ecosystem介绍</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/个人日志/">个人日志</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/云原生/">云原生</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储引擎/">存储引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库与大数据/">数据库与大数据</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器/">服务器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算引擎/">计算引擎</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/">论文阅读</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维工具/">运维工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目管理/">项目管理</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SQL引擎/" style="font-size: 15px;">SQL引擎</a> <a href="/tags/B-树/" style="font-size: 15px;">B+树</a> <a href="/tags/职场感悟/" style="font-size: 15px;">职场感悟</a> <a href="/tags/技术管理/" style="font-size: 15px;">技术管理</a> <a href="/tags/开源协议/" style="font-size: 15px;">开源协议</a> <a href="/tags/Drill/" style="font-size: 15px;">Drill</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/MPP/" style="font-size: 15px;">MPP</a> <a href="/tags/查询计划/" style="font-size: 15px;">查询计划</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/RocksDB/" style="font-size: 15px;">RocksDB</a> <a href="/tags/LSM树/" style="font-size: 15px;">LSM树</a> <a href="/tags/存储引擎/" style="font-size: 15px;">存储引擎</a> <a href="/tags/Hive/" style="font-size: 15px;">Hive</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/正向代理/" style="font-size: 15px;">正向代理</a> <a href="/tags/反向代理/" style="font-size: 15px;">反向代理</a> <a href="/tags/OLAP/" style="font-size: 15px;">OLAP</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/类加载器/" style="font-size: 15px;">类加载器</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/业务/" style="font-size: 15px;">业务</a> <a href="/tags/SparkSQL/" style="font-size: 15px;">SparkSQL</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/helm/" style="font-size: 15px;">helm</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Calcite/" style="font-size: 15px;">Calcite</a> <a href="/tags/优化器/" style="font-size: 15px;">优化器</a> <a href="/tags/分布式事务/" style="font-size: 15px;">分布式事务</a> <a href="/tags/ACID/" style="font-size: 15px;">ACID</a> <a href="/tags/CAP/" style="font-size: 15px;">CAP</a> <a href="/tags/Raft/" style="font-size: 15px;">Raft</a> <a href="/tags/分布式一致性/" style="font-size: 15px;">分布式一致性</a> <a href="/tags/算法复杂度/" style="font-size: 15px;">算法复杂度</a> <a href="/tags/CBO/" style="font-size: 15px;">CBO</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/Intel/" style="font-size: 15px;">Intel</a> <a href="/tags/ARM/" style="font-size: 15px;">ARM</a> <a href="/tags/X86/" style="font-size: 15px;">X86</a> <a href="/tags/硬件/" style="font-size: 15px;">硬件</a> <a href="/tags/RAID/" style="font-size: 15px;">RAID</a> <a href="/tags/服务器/" style="font-size: 15px;">服务器</a> <a href="/tags/AnalyticDB/" style="font-size: 15px;">AnalyticDB</a> <a href="/tags/窗口函数/" style="font-size: 15px;">窗口函数</a> <a href="/tags/Catalyst/" style="font-size: 15px;">Catalyst</a> <a href="/tags/行列存储/" style="font-size: 15px;">行列存储</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/tags/故障诊断/" style="font-size: 15px;">故障诊断</a> <a href="/tags/大数据meetup/" style="font-size: 15px;">大数据meetup</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/IT资讯/" style="font-size: 15px;">IT资讯</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/论文/" style="font-size: 15px;">论文</a> <a href="/tags/书籍/" style="font-size: 15px;">书籍</a> <a href="/tags/TopK/" style="font-size: 15px;">TopK</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2e4fb37a.html">极客邦连麦百位牛人观后实录</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/6d27f500.html">Java类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/b9b847a8.html">SparkSQL业务分析集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/bfe7107d.html">OLAP引擎-Kylin基本介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/ce4ffa9b.html">Hive性能调优实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/19c2ab93.html">Spark性能调优实战</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/c50a937d.html">PMP实践之路</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/7dec2e4.html">Calcite处理和扩展流程解析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/4c70dee6.html">分布式事务与一致性</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/75c48487.html">2020-DTCC-参会分享</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://changbo.tech/blog/ec4cdf4c.html" title="行业博客" target="_blank">行业博客</a><ul></ul><a href="https://leetcode-cn.com/" title="leetcode" target="_blank">leetcode</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Tony's Notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>