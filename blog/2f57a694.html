<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="bigdata, ai, 中间件、算法、大数据、人工智能"><title>正则表达式 | Tony's Notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">正则表达式</h1><a id="logo" href="/.">Tony's Notes</a><p class="description">Stay Hungry, Stay Foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">正则表达式</h1><div class="post-meta">Oct 1, 2012<span> | </span><span class="category"><a href="/categories/编程语言/">编程语言</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 10</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h3 id="Java中的正则表达式工具包"><a href="#Java中的正则表达式工具包" class="headerlink" title="Java中的正则表达式工具包"></a>Java中的正则表达式工具包</h3><p>包名：java.util.regex.用于匹配字符序列与正则表达式指定模式的类<br>接口：MatchResult:匹配操作的结果<br>类：</p>
<ul>
<li>Matcher:通过解释 Pattern 对 character sequence 执行匹配操作的引擎</li>
<li>Pattern:正则表达式的编译表示形式。</li>
<li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"a*b"</span>);</span><br><span class="line">Matcher m = p.matcher(<span class="string">"aaaaab"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = m.matches();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="正则表达式的基本语法-（部分参考）"><a href="#正则表达式的基本语法-（部分参考）" class="headerlink" title="正则表达式的基本语法 （部分参考）"></a>正则表达式的基本语法 （部分<a href="http://doslin.com/learn-regular-expressions-in-about-55-minutes/" target="_blank" rel="noopener">参考</a>）</h3><a id="more"></a>
<p>由只代表自身的 <strong>字面值</strong> 和代表特定含义的 <strong>元字符</strong> 组成。  </p>
<p>字面值：大部分字符，包括 <strong>字母数字字符</strong>，会以字面值的形式出现。这意味着它们 <strong>查找的是自身</strong>。比如，正则表达式 <code>bobo</code>，就是先找到b，接着o，然后是b，最后找到o。</p>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><ul>
<li><code>.</code> 表示匹配任何单字符（与 <strong>行结束符</strong> 可能匹配也可能不匹配）</li>
<li>任何 <strong>元字符</strong> 如果用一个 <strong>反斜杆</strong> <code>\</code> 进行转义就会变成字面值</li>
<li><p>如果未指定 DOTALL 标志，则正则表达式 <code>.</code> 可以与任何字符（<strong>行结束符除外</strong>）匹配</p>
</li>
<li><p><strong>行结束符</strong></p>
<ul>
<li>一个或两个字符的序列，标记输入字符序列的行结尾。</li>
<li>新行（换行）符 (‘\n’)</li>
<li>后面紧跟新行符的回车符 (“\r\n”)</li>
<li>单独的回车符 (‘\r’)</li>
<li>下一行字符 (‘\u0085’)</li>
<li>行分隔符 (‘\u2028’)</li>
<li>段落分隔符 (‘\u2029)</li>
</ul>
</li>
<li><p><code>\</code> <strong>反斜杠</strong> 是一个元字符，这意味着它也可以使用反斜杠转义。示例：</p>
<ul>
<li><code>b.b.</code> 能够匹配bobo,  b b</li>
<li><code>b\.b\.</code> 只能匹配b.b. 这里的.是字面值，不是元字符；</li>
<li><code>b\\</code> 只能匹配<code>b\</code> 这里 <code>\</code> 也是字面值。上述. <code>\</code>  都已经通过 <code>\</code> 进行转义,把元字符变为字面值</li>
<li><code>\t</code> 制表符 (‘\u0009’)</li>
<li><code>\n</code> 新行（换行）符 (‘\u000A’)</li>
<li><code>\r</code> 回车符 (‘\u000D’)</li>
<li><code>\f</code> 换页符 (‘\u000C’)</li>
<li><code>\a</code> 报警 (bell) 符 (‘\u0007’)</li>
<li><code>\e</code> 转义符 (‘\u001B’)</li>
<li><code>\\</code> 反斜线字符</li>
<li><code>x</code> 字符 x</li>
</ul>
</li>
</ul>
<h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><p><strong>字符类</strong> 是字符在方括号<code>[ ]</code>中的集合，表示“找到集合里任意一个字符”。<br>存在一些字符，在[ ]中和外面，有的含义是不一样的，有的含义一致。</p>
<ul>
<li>比如，<code>.</code>表示匹配任意字符，<code>[.]</code>表示匹配字面值<code>.</code></li>
<li><code>[a-z]</code>表示匹配<code>a-z</code>范围中任意字符，<code>a</code>表示匹配<code>a</code></li>
<li><code>a|b</code>表示匹配<code>a</code>或者<code>b</code>，<code>[a|b]</code>表示匹配字符<code>a</code>，字符<code>|</code>，字符<code>b</code></li>
</ul>
<p>常用字符类表</p>
<table>
<thead>
<tr>
<th>字符类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>[abc]</code></td>
<td>a、b 或 c（简单类）</td>
</tr>
<tr>
<td> <code>[^abc]</code></td>
<td>任何字符，除了 a、b 或 c（否定），其中<code>^</code>表示否定，通过<code>\^</code>可转义成字面值，如<code>[^\^]</code>表示找到除了插入符外的任意字符。</td>
</tr>
<tr>
<td> <code>[a-zA-Z]</code></td>
<td>a 到 z 或 A 到 Z，两头的字母包括在内（范围）</td>
</tr>
<tr>
<td> <code>[a-d[m-p]]</code></td>
<td>a 到 d <strong>或</strong> m 到 p：[a-dm-p]（并集）</td>
</tr>
<tr>
<td> <code>[a-z&amp;&amp;[^bc]]</code></td>
<td>a 到 z，<strong>除了 b 和 c</strong>：[ad-z]（减去）</td>
</tr>
<tr>
<td> <code>[a-z&amp;&amp;[^m-p]]</code></td>
<td>a 到 z，而非 m 到 p：[a-lq-z]（减去）</td>
</tr>
<tr>
<td> <code>[0-9.,]</code></td>
<td>匹配一个数字或者一个句点或者一个逗号</td>
</tr>
<tr>
<td> <code>[0-9a-fA-F]</code></td>
<td>匹配一位十六进制数</td>
</tr>
<tr>
<td> <code>[a-zA-Z0-9\-]</code></td>
<td>匹配一个字母数字字符或连字符</td>
</tr>
<tr>
<td> <code>[0-9]</code></td>
<td>表示匹配0-9中的一个数字，但是<code>[1-31]</code>并不是匹配1-31之间的数字，而是1或2或3，当成了<code>[1-3][1]</code></td>
</tr>
</tbody>
</table>
<h4 id="预定义字符类"><a href="#预定义字符类" class="headerlink" title="预定义字符类"></a>预定义字符类</h4><p> 用一些元字符来预先定义字符的范围。常见的对应关系：</p>
<table>
<thead>
<tr>
<th>预定义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>\d</code></td>
<td>数字：<code>[0-9]</code></td>
</tr>
<tr>
<td>  <code>\D</code></td>
<td>非数字： <code>[^0-9]</code></td>
</tr>
<tr>
<td>  <code>\w</code></td>
<td>单词字符：<code>[a-zA-Z_0-9]</code>，<strong>字母</strong> 或 <strong>数字</strong> 或 <strong>下划线</strong></td>
</tr>
<tr>
<td>  <code>\W</code></td>
<td>非单词字符：<code>[^\w]</code></td>
</tr>
<tr>
<td>  <code>\s</code></td>
<td>空白字符：<code>[ \t\n\x0B\f\r]</code> 空格，tab，回车或者换行等</td>
</tr>
<tr>
<td>  <code>\S</code></td>
<td>非空白字符：<code>[^\s]</code></td>
</tr>
</tbody>
</table>
<h4 id="乘法器"><a href="#乘法器" class="headerlink" title="乘法器"></a>乘法器</h4><p> 可以在一个<strong>字面值</strong>或者<strong>字符类</strong>后跟着一个<strong>大括号</strong>来使用乘法器。常见用法:</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>X{n}</code></td>
<td>X，恰好 n 次</td>
</tr>
<tr>
<td><code>X{n,}</code></td>
<td>X，至少 n 次</td>
</tr>
<tr>
<td><code>X{n,m}</code></td>
<td>X，至少 n 次，但是不超过 m 次  </td>
</tr>
<tr>
<td><code>X?</code></td>
<td>X，一次或一次也没有，相当于<code>X{0,1}</code></td>
</tr>
<tr>
<td><code>X*</code></td>
<td>X，零次或多次，相当于<code>X{0,}</code></td>
</tr>
<tr>
<td><code>X+</code></td>
<td>X，一次或多次 ，相当于<code>X{1,}</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p> <strong>注意</strong>：表格中出现的{，}，?，+，<em>等符号，放在[ ]中，就变为了字面值[{}+?]，{}+\?也都变为字面值了</em>。</p>
</blockquote>
<h4 id="惰性Non-greedy，勉强Reluctant"><a href="#惰性Non-greedy，勉强Reluctant" class="headerlink" title="惰性Non-greedy，勉强Reluctant"></a>惰性Non-greedy，勉强Reluctant</h4><p> 乘法器可通过<strong>追加问号?</strong>来实现惰性。这里对优先顺序进行了反转，优先匹配字符少的。示例：</p>
<ul>
<li><code>\d{4,5}?</code>表示“匹配<code>\d\d\d\d</code>或<code>\d\d\d\d\d</code>”。其实跟<code>\d{4}</code>行为一致。</li>
<li><code>&quot;.*?&quot;</code>表示“匹配一个双引号，跟着一个<strong>尽可能少的字符</strong>，再跟着一个双引号”。</li>
</ul>
<p>常见用法</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>X{n}?</code></td>
<td>X，恰好 n 次</td>
</tr>
<tr>
<td> <code>X{n,}?</code></td>
<td>X，至少 n 次</td>
</tr>
<tr>
<td> <code>X{n,m}?</code></td>
<td>X，至少 n 次，但是不超过 m 次  </td>
</tr>
<tr>
<td> <code>X??</code></td>
<td>X，一次或一次也没有，相当于<code>X{0,1}</code></td>
</tr>
<tr>
<td> <code>X*?</code></td>
<td>X，零次或多次，相当于<code>X{0,}</code></td>
</tr>
<tr>
<td> <code>X+?</code></td>
<td>X，一次或多次 ，相当于<code>X{1,}</code></td>
</tr>
</tbody>
</table>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>主要分类</p>
<ul>
<li><code>XY</code> 表示X 后跟 Y</li>
<li><code>X|Y</code>表示 X 或 Y ，分支，你可以使用<strong>管道符号</strong>来实现匹配多种选择</li>
<li><code>(X)</code> 表示X，作为捕获组。</li>
</ul>
<p>X|Y</p>
<ul>
<li><code>cat|dog</code>表示“匹配cat或dog”。</li>
<li><code>red|blue|</code>和<code>red||blue</code>以及<code>|red|blue</code>都是同样的意思，“匹配<strong>red</strong>或<strong>blue</strong>或<strong>空字符串</strong>”</li>
<li><code>a|b|c</code>跟<code>[abc]</code>一样</li>
<li>cat|dog|\ |表示“匹配<code>cat</code>或<code>dog</code>或<code>|</code>符号”。其中 \ | 被转义了，<code>|</code>属于字面字符。</li>
<li><code>[cat|dog]</code>表示“找到a或c或d或d或g或o或t或一个管道符号|”.</li>
</ul>
<p>(X)</p>
<ul>
<li>在一周中找到一天，使用<code>(Mon|Tues|Wednes|Thurs|Fri|Satur|Sun)day</code></li>
<li><code>\(\)</code>表示“匹配一个左圆括号后，再匹配一个右圆括号”</li>
<li><code>[()]</code>表示“匹配一个左圆括号或一个右圆括号”</li>
<li><code>(red|blue)?</code>等同于<code>(red|blue|)</code></li>
<li><code>\w+(\s+\w+)*</code>代表“找到一个或多个单词，它们以空格隔开”</li>
<li>主要用途：括号是用来表示<strong>组</strong>的，也可以用来<strong>捕获子串</strong>。</li>
<li><p>捕获组：可以拥有<strong>多个捕获组</strong>，它们甚至可以<strong>嵌套使用</strong>。捕获组从左到右进行编号。只要计算左圆括号。    </p>
<p>示例1：<code>(\w+) had a ((\w+) \w+)</code>，从左往右的话，共3个组，分别为<code>(\w+)</code>、<code>((\w+) \w+)</code>和<code>(\w+)</code>。 代码：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> regex=<span class="string">"(\\w+) had a ((\\w+) \\w+)"</span>;</span><br><span class="line">str=<span class="string">"I had a nice day"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line"></span><br><span class="line">System.out.println(matcher.matches());</span><br><span class="line">System.out.println(matcher.groupCount());<span class="comment">//返回组的总数</span></span><br><span class="line">System.out.println(matcher.group(<span class="number">0</span>));<span class="comment">//表示完整匹配</span></span><br><span class="line">System.out.println(matcher.group(<span class="number">1</span>));<span class="comment">//匹配(\\w+)</span></span><br><span class="line">System.out.println(matcher.group(<span class="number">2</span>));<span class="comment">//匹配((\\w+) \\w+)</span></span><br><span class="line">System.out.println(matcher.group(<span class="number">3</span>));<span class="comment">//匹配(\\w+)</span></span><br><span class="line"><span class="comment">//System.out.println(matcher.group(4));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="comment">//从一个成功返回的匹配中捕获组数量总是等于原来正则表达式中捕获组的数量</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">I had a nice day</span><br><span class="line">I</span><br><span class="line">nice day</span><br><span class="line">nice</span><br></pre></td></tr></table></figure>
<p>  示例2：正则表达式((cat)|dog)表示“匹配cat或dog”。这里总是存在两组捕获组。如果我们的输入文本是dog，那么捕获组1是dog，捕获组2是空字符串，因为另一个选择未被使用。代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">regex=<span class="string">"((cat)|dog)"</span>;</span><br><span class="line">str=<span class="string">"dog"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line"></span><br><span class="line">System.out.println(matcher.matches());</span><br><span class="line">System.out.println(matcher.groupCount());<span class="comment">//返回组的总数</span></span><br><span class="line"><span class="comment">//System.out.println(matcher.group(0));//表示完整匹配</span></span><br><span class="line">System.out.println(matcher.group(<span class="number">1</span>));<span class="comment">//匹配(\\w+)</span></span><br><span class="line">System.out.println(matcher.group(<span class="number">2</span>));<span class="comment">//匹配((\\w+) \\w+)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">dog</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>替换<br> 一旦你用了正则表达式来查找字符串，你可以指定另一个字符串来替换它。第二个字符串时替换表达式。你尝试去用ISO 8691格式的日期（YYYY-MM-DD）去替换美式日期（MM/DD/YY）</p>
<ul>
<li>通过正则表达式<code>(\d\d)/(\d\d)/(\d\d)</code>开始。注意这里有三个捕获组：月，日和两个数字表示的年。通过使用一<strong>一个反斜</strong>和一个<strong>捕获组号</strong>来引用一个捕获组。所以，你的替换表达式为<code>20\3-\1-\2</code>。<code>\3</code>表示引用<code>YY</code>,<code>\1</code>表示引用<code>MM</code>,<code>\2</code>表示引用<code>DD</code>。</li>
<li>代码（调试中?）</li>
</ul>
</li>
<li><p>向后引用<br> <code>([abc])\1</code>表示“匹配aa或bb或cc”。其中<code>\1</code>表示引用第一个捕获组号，如果捕获组中匹配的是a，那么<code>\1</code>就表示a。代码示例：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">regex=<span class="string">"([abc])([cd])\\1\\2"</span>;</span><br><span class="line">	str=<span class="string">"cdcd"</span>;</span><br><span class="line">	Pattern pattern = Pattern.compile(regex);</span><br><span class="line">	Matcher matcher = pattern.matcher(str);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(matcher.matches()) &#123;</span><br><span class="line">  <span class="comment">//一定要先执行匹配成功了，才能统计下面的组</span></span><br><span class="line">		System.out.println(matcher.matches());</span><br><span class="line">		System.out.println(matcher.groupCount());</span><br><span class="line">		System.out.println(matcher.group(<span class="number">1</span>));</span><br><span class="line">		System.out.println(matcher.group(<span class="number">2</span>));</span><br><span class="line">		<span class="comment">//System.out.println(matcher.group(3));</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//结果</span></span><br><span class="line">		<span class="keyword">true</span></span><br><span class="line">		<span class="number">2</span></span><br><span class="line">		c</span><br><span class="line">		d</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="边界匹配器"><a href="#边界匹配器" class="headerlink" title="边界匹配器"></a>边界匹配器</h4><p>分类  </p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>     <code>^</code></td>
<td>行的开头，<strong>行头</strong></td>
</tr>
<tr>
<td>     <code>$</code></td>
<td>行的结尾，<strong>行尾</strong></td>
</tr>
<tr>
<td>     <code>\b</code></td>
<td>单词边界</td>
</tr>
<tr>
<td>     <code>\B</code></td>
<td>非单词边界</td>
</tr>
<tr>
<td>     <code>\A</code></td>
<td>输入的开头</td>
</tr>
<tr>
<td>     <code>\G</code></td>
<td>上一个匹配的结尾</td>
</tr>
<tr>
<td>     <code>\Z</code></td>
<td>输入的结尾，仅用于最后的结束符（如果有的话）</td>
</tr>
<tr>
<td>     <code>\z</code></td>
<td>输入的结尾</td>
</tr>
</tbody>
</table>
<p><strong>单词</strong> 边界</p>
<ul>
<li>单词边界是 <strong>一个单词字符</strong>和<strong>非单词字符</strong> 之间的位置。</li>
<li>单词边界不是字符。它们宽度为零。</li>
<li>输入的文本it’s a cat有八个单词边界。如果我们在cat后追加一个空格，这里就会有九个单词边界。</li>
<li><code>\b\w\w\w\b</code>表示“匹配一个三个字母的单词”。</li>
</ul>
<p><strong>行</strong> 边界</p>
<ul>
<li>每一块文本会分解成一个或多个行，用换行符分隔。</li>
<li>像单词边界一样，行边界也不是字符。它们宽度为零。</li>
<li>文本不是以换行符结束，而是<strong>以行结束</strong>。然而，任何行，包括最后一行，可以包含零个字符。</li>
<li><strong>行头位置</strong> 是在一个换行符和下一行的第一个字符之间。与单词边界一样，在文本的开头也算作一个起始的行。</li>
<li><strong>行尾位置</strong> 是在行的最后一个字符和换行符之间。与单词边界一样，文本结束也算作行结束。</li>
<li>用法：<ul>
<li><code>^$</code>表示“匹配空行”。</li>
<li><code>^.*$</code>将会匹配整个文本，因为换行符是一个字符，所以<code>.</code>会匹配它。为了匹配单行，要使用惰性乘法器，<code>^.*?$</code>。</li>
<li><code>\^\$</code>表示“匹配尖符号后跟着一个美元符号”</li>
<li><code>[$]</code>表示“匹配一个美元符”。然而，<code>[^]</code>是非法单正则表达式。要记住的是尖符号在方括号中时有不同的特殊含义。把尖符号放在字符类中，这么用<code>[\^]</code>。</li>
</ul>
</li>
</ul>
<p><strong>文本</strong> 边界</p>
<ul>
<li>从“行开始”和“行结束”变成“文本开始”和“文本结束”。</li>
<li>元字符<code>\A</code>和<code>\z</code></li>
</ul>
</div><iframe src="/donate/?AliPayQR=/uploads/alipay.png&amp;WeChatQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://changbo.tech/blog/2f57a694.html" data-id="cktlq5e7o004g6nvxmbihi0kh" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABxElEQVR42u3aSW7DMBAEQP3/084DDCjdHJEKguLJgGmq5MNgFl5XvD7B+t6ZnHntWLi4uGNui0j2f4Mm5+Pi4r7FvQ8095/vg9c9MTfg4uL+ZW4OTYIaLi7u/+AmD24puLi4f5ObFCft0S/Xari4uANu3qXc93lLfxcXF3eJ+ylXflrSEKmfjouLe4SbB5Qk6cmHK5O/ABcXdzc3+Vny7dr1izyTufKjcXFxH+KuhZj8Ze5fowiIuLi4R7hJ6MkvWDwV2n4ZxuDi4h7k5qORNiS1nc/FWg0XF/chbt7czMcq7ci2uJaBi4t7hNsWM22Aa3fW6REuLu5mbh6AorwpbnysvTYuLu5JblIOJSlOe7VrMZDh4uJu465dpMhD23zgWsRFXFzcDdx8vDG5VDF6Li4u7kvcfGi6NlBZeyIuLu557mRo2pZPdVqTZ1W4uLhj7qdcScrSjlqL5AkXF/cId1K6TEankxYtLi7uGW57lSrfM2mqLiY6uLi4j3InY9G1AikvoqL+Li4u7qvctuk5L5NGgQwXF/cId61+mpzwWNzFxcUtue3VyeQ6xaRhGg1ZcXFxt3HrUFI2UttSah40cXFxB9wfd7aaeZjAxpMAAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/正则表达式/">正则表达式</a></div><div class="post-nav"><a class="pre" href="/blog/d0befed5.html">Hadoop Ecosystem介绍</a><a class="next" href="/blog/cf64afc8.html">5种开源协议的用途和比较</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/个人日志/">个人日志</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/云原生/">云原生</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储引擎/">存储引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库与大数据/">数据库与大数据</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器/">服务器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算引擎/">计算引擎</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/">论文阅读</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维工具/">运维工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目管理/">项目管理</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SQL引擎/" style="font-size: 15px;">SQL引擎</a> <a href="/tags/B-树/" style="font-size: 15px;">B+树</a> <a href="/tags/职场感悟/" style="font-size: 15px;">职场感悟</a> <a href="/tags/技术管理/" style="font-size: 15px;">技术管理</a> <a href="/tags/开源协议/" style="font-size: 15px;">开源协议</a> <a href="/tags/Drill/" style="font-size: 15px;">Drill</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/MPP/" style="font-size: 15px;">MPP</a> <a href="/tags/查询计划/" style="font-size: 15px;">查询计划</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/RocksDB/" style="font-size: 15px;">RocksDB</a> <a href="/tags/LSM树/" style="font-size: 15px;">LSM树</a> <a href="/tags/存储引擎/" style="font-size: 15px;">存储引擎</a> <a href="/tags/Hive/" style="font-size: 15px;">Hive</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/正向代理/" style="font-size: 15px;">正向代理</a> <a href="/tags/反向代理/" style="font-size: 15px;">反向代理</a> <a href="/tags/OLAP/" style="font-size: 15px;">OLAP</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/类加载器/" style="font-size: 15px;">类加载器</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/业务/" style="font-size: 15px;">业务</a> <a href="/tags/SparkSQL/" style="font-size: 15px;">SparkSQL</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/helm/" style="font-size: 15px;">helm</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Calcite/" style="font-size: 15px;">Calcite</a> <a href="/tags/优化器/" style="font-size: 15px;">优化器</a> <a href="/tags/分布式事务/" style="font-size: 15px;">分布式事务</a> <a href="/tags/ACID/" style="font-size: 15px;">ACID</a> <a href="/tags/CAP/" style="font-size: 15px;">CAP</a> <a href="/tags/Raft/" style="font-size: 15px;">Raft</a> <a href="/tags/分布式一致性/" style="font-size: 15px;">分布式一致性</a> <a href="/tags/算法复杂度/" style="font-size: 15px;">算法复杂度</a> <a href="/tags/CBO/" style="font-size: 15px;">CBO</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/Intel/" style="font-size: 15px;">Intel</a> <a href="/tags/ARM/" style="font-size: 15px;">ARM</a> <a href="/tags/X86/" style="font-size: 15px;">X86</a> <a href="/tags/硬件/" style="font-size: 15px;">硬件</a> <a href="/tags/RAID/" style="font-size: 15px;">RAID</a> <a href="/tags/服务器/" style="font-size: 15px;">服务器</a> <a href="/tags/AnalyticDB/" style="font-size: 15px;">AnalyticDB</a> <a href="/tags/窗口函数/" style="font-size: 15px;">窗口函数</a> <a href="/tags/Catalyst/" style="font-size: 15px;">Catalyst</a> <a href="/tags/行列存储/" style="font-size: 15px;">行列存储</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/tags/故障诊断/" style="font-size: 15px;">故障诊断</a> <a href="/tags/大数据meetup/" style="font-size: 15px;">大数据meetup</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/IT资讯/" style="font-size: 15px;">IT资讯</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/论文/" style="font-size: 15px;">论文</a> <a href="/tags/书籍/" style="font-size: 15px;">书籍</a> <a href="/tags/TopK/" style="font-size: 15px;">TopK</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2e4fb37a.html">极客邦连麦百位牛人观后实录</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/6d27f500.html">Java类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/b9b847a8.html">SparkSQL业务分析集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/bfe7107d.html">OLAP引擎-Kylin基本介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/ce4ffa9b.html">Hive性能调优实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/19c2ab93.html">Spark性能调优实战</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/c50a937d.html">PMP实践之路</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/7dec2e4.html">Calcite处理和扩展流程解析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/4c70dee6.html">分布式事务与一致性</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/75c48487.html">2020-DTCC-参会分享</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://changbo.tech/blog/ec4cdf4c.html" title="行业博客" target="_blank">行业博客</a><ul></ul><a href="https://leetcode-cn.com/" title="leetcode" target="_blank">leetcode</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Tony's Notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>