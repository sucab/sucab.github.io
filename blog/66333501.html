<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="bigdata, ai, 中间件、算法、大数据、人工智能"><title>Drill执行引擎介绍 | Tony's Notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Drill执行引擎介绍</h1><a id="logo" href="/.">Tony's Notes</a><p class="description">Stay Hungry, Stay Foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Drill执行引擎介绍</h1><div class="post-meta">Feb 10, 2020<span> | </span><span class="category"><a href="/categories/计算引擎/">计算引擎</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.9k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 21</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>Apache Drill是一个低延迟的分布式查询引擎，用于大规模数据集，包括结构化和半结构化/嵌套数据。受Google的Dremel启发，Drill被设计成可扩展到数千个节点，并以BI/分析环境所需的交互速度查询数PB的数据。Drill对于大型数据集上的简短、交互式即席查询也很有用。Drill能够以JSON和Parquet等格式查询嵌套数据，并执行动态模式发现。</p>
<p>Drill具有高吞吐和低延迟的特性，它不使用像MapReduce、Tez或Spark这样的通用执行引擎。因此，Drill是灵活和高效的。Drill的优化器利用了基于规则和成本的优化技术，以及数据局部性和操作下推，具备将查询片段下推到后端数据源的能力。Drill还提供了一个列式和矢量化的执行引擎，从而提高了内存和CPU的效率。</p>
<p>如果为了简单使用，可以下载并且直接运行在笔记本电脑。当用于分析更大的数据集时，可以在Hadoop集群（最多可达1000个节点）上直接部署Drill。Drill利用集群中的聚合内存，使用乐观的流水线模型执行查询，并在工作集不适合内存时自动溢出到磁盘。</p>
<p>下面，本文将从Drill执行引擎的整体架构以及优化器技术、物理计划生成和执行方面，结合源代码进行分析介绍。</p>
<h4 id="2-整体架构"><a href="#2-整体架构" class="headerlink" title="2. 整体架构"></a>2. 整体架构</h4><p>Drill包括一个分布式执行环境，专门为大规模数据处理而构建。它的核心是Drillbit服务，负责接收来自客户端的请求、处理查询并将结果返回给客户端（如下图一所示）。可以在Hadoop集群中的所有必须节点上安装并运行Drillbit服务，以形成分布式集群环境。当Drillbit在集群中的每个数据节点上运行时，Drill可以在查询执行过程中最大化数据局部性，而无需再网络上或节点之间移动数据。Drill使用Zookeeper维护集群成员和健康检测信息。当然，Drill不与Hadoop绑定 ，可以在任何分布式集群环境中运行。唯一的前提条件是依赖Zookeeper。</p>
<p><img src="/blog/66333501/query-flow-client.png" alt></p>
<p><center>图一  客户端与Drillbit的关系</center><br>当Drillbit接收到客户端查询时，就成为了Foreman来驱动整个查询，如下图二所示。首先，Foreman中的解析器负责解析SQL，应用自定义规则将特定的SQL运算符转换为Drill可以理解的特定逻辑预算符，以此来形成一个逻辑计划。逻辑计划描述了生成查询结果所需的工作，并定义了要应用的数据源和操作。</p>
<p>其次，Foreman将逻辑计划发送到基于成本的优化器中，优化器应用各种类型的规则，将运算符和函数重新排列到最优计划中。优化器将逻辑计划转换为描述如何执行查询的物理计划。</p>
<p><img src="/blog/66333501/client-phys-plan.png" alt></p>
<p><center>图二  SQL到物理计划流程</center><br>Foreman中的并行化器将物理计划转换为多个阶段，称为major fragment和minor fragment。这些fragment创建了一个多级执行树，该树重写查询并对配置的数据源并行执行查询，将结果发送回客户端或应用程序。如图三所示。</p>
<p><img src="/blog/66333501/execution-tree.png" alt></p>
<p><center>图三 执行树</center></p>
<h4 id="3-查询接入"><a href="#3-查询接入" class="headerlink" title="3. 查询接入"></a>3. 查询接入</h4><p>第一步，Drillbit服务端接收请求的处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.rpc.user;</span><br><span class="line"><span class="comment">//包引入省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServerRequestHandler</span> <span class="keyword">implements</span> <span class="title">RequestHandler</span>&lt;<span class="title">BitToUserConnection</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//处理各种用户的请求</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> UserWorker worker;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(BitToUserConnection connection, <span class="keyword">int</span> rpcType, ByteBuf pBody, ByteBuf dBody, ResponseSender responseSender)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">case</span> RpcType.RUN_QUERY_VALUE:<span class="comment">//执行查询</span></span><br><span class="line">      logger.debug(<span class="string">"Received query to run.  Returning query handle."</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//解析请求为RunQuery protobuf信息</span></span><br><span class="line">        <span class="keyword">final</span> RunQuery query = RunQuery.PARSER.parseFrom(<span class="keyword">new</span> ByteBufInputStream(pBody));</span><br><span class="line">        <span class="comment">//提交查询，并返回一个查询ID</span></span><br><span class="line">        <span class="keyword">final</span> QueryId queryId = worker.submitWork(connection, query);</span><br><span class="line">        <span class="comment">//设置返回的响应信息</span></span><br><span class="line">        responseSender.send(<span class="keyword">new</span> Response(RpcType.QUERY_HANDLE, queryId));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failure while decoding RunQuery body."</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> RpcType.CANCEL_QUERY_VALUE:<span class="comment">//取消查询</span></span><br><span class="line">      	<span class="comment">//省略 worker.cancelQuery(queryId);</span></span><br><span class="line">      <span class="keyword">case</span> RpcType.RESUME_PAUSED_QUERY_VALUE:<span class="comment">//恢复暂停的查询</span></span><br><span class="line">      	<span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> RpcType.GET_QUERY_PLAN_FRAGMENTS_VALUE:<span class="comment">//获取查询计划fragment</span></span><br><span class="line">      	<span class="comment">//省略 worker.getQueryPlan(connection, req)</span></span><br><span class="line">      <span class="keyword">case</span> RpcType.GET_CATALOGS_VALUE:<span class="comment">//获取所有数据库分类，默认为DRILL</span></span><br><span class="line">      	<span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> RpcType.GET_SCHEMAS_VALUE:<span class="comment">//获取所有数据库</span></span><br><span class="line">      	<span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> RpcType.GET_TABLES_VALUE:<span class="comment">//获取指定库下的所有表</span></span><br><span class="line">      	<span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> RpcType.GET_COLUMNS_VALUE:<span class="comment">//获取指定表下的所有列</span></span><br><span class="line">      	<span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> RpcType.CREATE_PREPARED_STATEMENT_VALUE:</span><br><span class="line">      	<span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> RpcType.GET_SERVER_META_VALUE:<span class="comment">//获取服务端相关配置信息</span></span><br><span class="line">      	<span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">          String.format(<span class="string">"UserServerRequestHandler received rpc of unknown type. Type was %d."</span>, rpcType));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，解析出请求类型后，进行相应处理。比如是查询请求，则初始化Foreman开始处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.work.user;</span><br><span class="line"><span class="comment">//包引入省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserWorker</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//管理foreman的执行</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> WorkerBee bee;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//提交查询</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> QueryId <span class="title">submitWork</span><span class="params">(UserClientConnection connection, RunQuery query)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成查询ID</span></span><br><span class="line">    <span class="keyword">final</span> QueryId id = queryIdGenerator();</span><br><span class="line">    <span class="comment">//本次会话查询数量加1</span></span><br><span class="line">    incrementer.increment(connection.getSession());</span><br><span class="line">    <span class="comment">//初始化包工头，是一个线程</span></span><br><span class="line">    Foreman foreman = <span class="keyword">new</span> Foreman(bee, bee.getContext(), connection, id, query);</span><br><span class="line">    <span class="comment">//加入执行队列</span></span><br><span class="line">    bee.addNewForeman(foreman);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，Foreman在驱动节点或根节点上，为单个查询管理所有的fragments(本地或远程)。主要流程为：当Foreman初始化时，查询处于准备状态。作为Runnable被提交进入队列排队，用于执行查询计划。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.work.foreman;</span><br><span class="line"><span class="comment">//包引入省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foreman</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//处理查询执行的一些细节，每个Foreman都持有一个</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> QueryManager queryManager;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> QueryStateProcessor queryStateProcessor;</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Foreman</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">this</span>.queryManager = <span class="keyword">new</span> QueryManager(queryId, queryRequest, drillbitContext.getStoreProvider(), drillbitContext.getClusterCoordinator(), <span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">//初始状态为：QueryState.PREPARING;</span></span><br><span class="line">      <span class="keyword">this</span>.queryStateProcessor = <span class="keyword">new</span> QueryStateProcessor(queryIdString, queryManager, drillbitContext, <span class="keyword">new</span> ForemanResult());</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//部分省略...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//检测foreman是否在线，否则不能接收新的查询</span></span><br><span class="line">      <span class="keyword">if</span> (!drillbitContext.isForemanOnline()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ForemanException(<span class="string">"Query submission failed since Foreman is shutting down."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ForemanException e) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Failure while submitting query"</span>, e);</span><br><span class="line">      <span class="comment">//新增QueryState.FAILED的事件</span></span><br><span class="line">      queryStateProcessor.addToEventQueue(QueryState.FAILED, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从QueryState.PREPARING状态切换到QueryState.PLANNING状态</span></span><br><span class="line">    queryStateProcessor.moveToState(QueryState.PLANNING, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 将查询请求转为具体的行为</span></span><br><span class="line">      <span class="keyword">switch</span> (queryRequest.getType()) &#123;</span><br><span class="line">          <span class="keyword">case</span> LOGICAL:<span class="comment">//请求是逻辑计划</span></span><br><span class="line">            parseAndRunLogicalPlan(queryRequest.getPlan());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> PHYSICAL:<span class="comment">//请求是物理计划</span></span><br><span class="line">            parseAndRunPhysicalPlan(queryRequest.getPlan());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> SQL:<span class="comment">//请求是SQL</span></span><br><span class="line">            <span class="keyword">final</span> String sql = queryRequest.getPlan();</span><br><span class="line">            logger.info(<span class="string">"Query text for query with id &#123;&#125; issued by &#123;&#125;: &#123;&#125;"</span>, queryIdString,queryContext.getQueryUserName(), sql);</span><br><span class="line">            runSQL(sql);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> EXECUTION:<span class="comment">//请求是fragments</span></span><br><span class="line">            runFragment(queryRequest.getFragmentsList());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> PREPARED_STATEMENT:<span class="comment">//请求是预编译</span></span><br><span class="line">            runPreparedStatement(queryRequest.getPreparedStatementHandle());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">     	<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当run方法执行完成后，foreman实例还一直存在，并且通过QueryManager的stateListener来间接地接收关于fragment完成的事件，直到一切都完成、失败或者被取消。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-查询执行"><a href="#4-查询执行" class="headerlink" title="4. 查询执行"></a>4. 查询执行</h4><p>查询请求进入Foreman后，针对SQL类查询，进入foreman#runSQL(sql)方法处理。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.work.foreman;</span><br><span class="line"><span class="comment">//包引入省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foreman</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//省略部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runSQL</span><span class="params">(<span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> ExecutionSetupException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Pointer&lt;String&gt; textPlan = <span class="keyword">new</span> Pointer&lt;&gt;();</span><br><span class="line">      <span class="comment">//将sql转为物理计划</span></span><br><span class="line">      <span class="keyword">final</span> PhysicalPlan plan = DrillSqlWorker.getPlan(queryContext, sql, textPlan);</span><br><span class="line">      <span class="comment">//执行物理计划</span></span><br><span class="line">      runPhysicalPlan(plan, textPlan);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-1-SQL转物理计划"><a href="#4-1-SQL转物理计划" class="headerlink" title="4.1 SQL转物理计划"></a>4.1 SQL转物理计划</h5><p>第一步，根据SQL类型进行相应的处理。比如，SQL查询进入DefaultSqlHandler#.getPlan(sqlNode)。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.planner.sql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrillSqlWorker</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将查询sql语句转为查询物理计划</span></span><br><span class="line"><span class="comment">   * 捕获各种异常并尽可能转为用户异常</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PhysicalPlan <span class="title">getPlan</span><span class="params">(QueryContext context, String sql, Pointer&lt;String&gt; textPlan)</span> <span class="keyword">throws</span> ForemanSetupException </span>&#123;</span><br><span class="line">    <span class="comment">//省略  convertPlan(context, sql, textPlan);</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * sql中使用的函数，本地函数库和远程函数库同步问题</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PhysicalPlan <span class="title">convertPlan</span><span class="params">(QueryContext context, String sql, Pointer&lt;String&gt; textPlan)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 省略 getQueryPlan(context, sql, textPlan);</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PhysicalPlan <span class="title">getQueryPlan</span><span class="params">(QueryContext context, String sql, Pointer&lt;String&gt; textPlan)</span> <span class="keyword">throws</span> ForemanSetupException, RelConversionException, IOException, ValidationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sql解析器，基于calcite parser.jj和自定义扩展parser.jj形成drill的sql解析</span></span><br><span class="line">    <span class="keyword">final</span> SqlConverter parser = <span class="keyword">new</span> SqlConverter(context);</span><br><span class="line">    <span class="comment">//生成calcite表示的抽象语法树（AST）</span></span><br><span class="line">    <span class="keyword">final</span> SqlNode sqlNode = checkAndApplyAutoLimit(parser, context, sql);</span><br><span class="line">    <span class="comment">//sql操作处理</span></span><br><span class="line">    <span class="keyword">final</span> AbstractSqlHandler handler;</span><br><span class="line">    <span class="keyword">final</span> SqlHandlerConfig config = <span class="keyword">new</span> SqlHandlerConfig(context, parser);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(sqlNode.getKind()) &#123;</span><br><span class="line">      <span class="keyword">case</span> EXPLAIN: <span class="comment">//查看sql执行计划</span></span><br><span class="line">       <span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> SET_OPTION:<span class="comment">//设置配置项</span></span><br><span class="line">       <span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> DESCRIBE_TABLE:<span class="comment">//查看表元数据</span></span><br><span class="line">       <span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> DESCRIBE_SCHEMA:<span class="comment">//查看数据库元数据</span></span><br><span class="line">       <span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> CREATE_TABLE:<span class="comment">//建表</span></span><br><span class="line">       <span class="comment">//省略</span></span><br><span class="line">      <span class="keyword">case</span> DROP_TABLE:</span><br><span class="line">      <span class="keyword">case</span> CREATE_VIEW:</span><br><span class="line">      <span class="keyword">case</span> DROP_VIEW:</span><br><span class="line">      <span class="keyword">case</span> OTHER_DDL:</span><br><span class="line">      <span class="keyword">case</span> OTHER:</span><br><span class="line">		<span class="comment">//省略</span></span><br><span class="line">        <span class="comment">// fallthrough</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//sql处理，主要用于AST向执行计划的转换（含基于规则和成本的优化）</span></span><br><span class="line">        handler = <span class="keyword">new</span> DefaultSqlHandler(config, textPlan);</span><br><span class="line">        context.setSQLStatementType(SqlStatementType.OTHER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    <span class="keyword">return</span> handler.getPlan(sqlNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，DefaultSqlHandler#getPlan(sqlNode)实现了AST转物理计划的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.planner.sql.handlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlHandler</span> <span class="keyword">extends</span> <span class="title">AbstractSqlHandler</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PhysicalPlan <span class="title">getPlan</span><span class="params">(SqlNode sqlNode)</span> <span class="keyword">throws</span> ValidationException, RelConversionException, IOException, ForemanSetupException </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 将AST转为关系表达式</span></span><br><span class="line"><span class="comment">     * 其中采用HepPlanner将subquery和window function阶段设置的静态规则进行SQL改写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ConvertedRelNode convertedRelNode = validateAndConvert(sqlNode);</span><br><span class="line">    <span class="keyword">final</span> RelDataType validatedRowType = convertedRelNode.getValidatedRowType();</span><br><span class="line">    <span class="keyword">final</span> RelNode queryRelNode = convertedRelNode.getConvertedNode();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 2. 将原始关系表达式RelNode转为Drill逻辑关系表达式DrillRelNode</span></span><br><span class="line"><span class="comment">	 * 2.1. 调用convertToRawDrel</span></span><br><span class="line"><span class="comment">	 * 2.2. 在最上层添加一个Screen算子，用于显示查询结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> DrillRel drel = convertToDrel(queryRelNode);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 将DrillRelNode转为Drill物理表达式PhysicalRelNode</span></span><br><span class="line"><span class="comment">     * 3.1 通过VolcanoPlanner通过内置的以及存储自己设置的物理规则进行优化调整 （考虑成本）</span></span><br><span class="line"><span class="comment">     * 3.2 针对join sql中多表字段冲突重命名</span></span><br><span class="line"><span class="comment">     * 3.3 inner join时左右表交换，大表在左，小表在右（构建hash表）</span></span><br><span class="line"><span class="comment">     * 3.4 将所有复杂输出拆解为对应的EXP$名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Prel prel = convertToPrel(drel, validatedRowType);</span><br><span class="line">    logAndSetTextPlan(<span class="string">"Drill Physical"</span>, prel, logger);</span><br><span class="line">    <span class="comment">// 4. 将Drill物理关系表达式转为Drill物理算子</span></span><br><span class="line">    <span class="keyword">final</span> PhysicalOperator pop = convertToPop(prel);</span><br><span class="line">    <span class="comment">// 5. 提取算子，构建root、leaf的graph</span></span><br><span class="line">    <span class="keyword">final</span> PhysicalPlan plan = convertToPlan(pop);</span><br><span class="line">    log(<span class="string">"Drill Plan"</span>, plan, logger);</span><br><span class="line">    <span class="keyword">return</span> plan;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> DrillRel <span class="title">convertToRawDrel</span><span class="params">(<span class="keyword">final</span> RelNode relNode)</span> <span class="keyword">throws</span> SqlUnsupportedException </span>&#123;</span><br><span class="line">    <span class="comment">//开启针对含有limit 0的查询进行优化</span></span><br><span class="line">    <span class="keyword">if</span> (context.getOptions().getOption(ExecConstants.EARLY_LIMIT0_OPT) &amp;&amp;</span><br><span class="line">        context.getPlannerSettings().isTypeInferenceEnabled() &amp;&amp;</span><br><span class="line">        FindLimit0Visitor.containsLimit0(relNode)) &#123;</span><br><span class="line">      <span class="keyword">final</span> DrillRel shorterPlan;</span><br><span class="line">      <span class="comment">//返回列类型都是可识别的，则直接生成特定执行计划</span></span><br><span class="line">      <span class="keyword">if</span> ((shorterPlan = FindLimit0Visitor.getDirectScanRelIfFullySchemaed(relNode)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> shorterPlan;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//针对limit 0的查询，关闭分布式模式</span></span><br><span class="line">      <span class="keyword">if</span> (FindHardDistributionScans.canForceSingleMode(relNode)) &#123;</span><br><span class="line">        context.getPlannerSettings().forceSingleMode();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 适用于HepPlanner优化器的规则，在VolcanoPlanner优化器中会失败的</span></span><br><span class="line">      <span class="comment">// 将集合操作算子（union)和其他算子进行转换</span></span><br><span class="line">      <span class="keyword">final</span> RelNode setOpTransposeNode = transform(PlannerType.HEP, PlannerPhase.PRE_LOGICAL_PLANNING, relNode);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过HepPlanner优化器从下往上的匹配顺序，进行目录剪枝优化。主要规则有：</span></span><br><span class="line">      <span class="comment">// 1. *转为字段引用，便于分区剪枝和下推规则来检测可以修改或下推的字段</span></span><br><span class="line">      <span class="comment">// 2. 没有group by或distinct的聚合，将scan优化为可以直接从统计信息获取</span></span><br><span class="line">      <span class="keyword">final</span> RelNode pruned = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.DIRECTORY_PRUNING, setOpTransposeNode);</span><br><span class="line">      <span class="comment">//为剪枝后的关系表达式加上Drill逻辑特性，关联Drill对关系表达式的相关实现</span></span><br><span class="line">      <span class="keyword">final</span> RelTraitSet logicalTraits = pruned.getTraitSet().plus(DrillRel.DRILL_LOGICAL);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> RelNode convertedRelNode;</span><br><span class="line">      <span class="keyword">if</span> (!context.getPlannerSettings().isHepOptEnabled()) &#123;</span><br><span class="line">        <span class="comment">// HepPlanner关闭（默认开启），采用VolcanoPlanner</span></span><br><span class="line">        <span class="comment">// LOGICAL_PRUNE_AND_JOIN 限定的规则集合，如分区剪枝和Join置换</span></span><br><span class="line">        convertedRelNode = transform(PlannerType.VOLCANO, PlannerPhase.LOGICAL_PRUNE_AND_JOIN, pruned, logicalTraits);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> RelNode intermediateNode2;</span><br><span class="line">        <span class="keyword">final</span> RelNode intermediateNode3;</span><br><span class="line">        <span class="comment">//默认开启通过HepPlanner进行分区剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (context.getPlannerSettings().isHepPartitionPruningEnabled()) &#123;</span><br><span class="line">		  <span class="comment">//采用基于成本代价的VolcanoPlanner进行逻辑计划优化</span></span><br><span class="line">          <span class="comment">// 1. PlannerPhase.LOGICAL 限定的规则集合</span></span><br><span class="line">          <span class="keyword">final</span> RelNode intermediateNode = transform(PlannerType.VOLCANO, PlannerPhase.LOGICAL, pruned, logicalTraits);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Hep对Join相关的优化，比如将join中的谓词传递到具体表中</span></span><br><span class="line">          <span class="comment">// 2. PlannerPhase.TRANSITIVE_CLOSURE 限定的规则集合</span></span><br><span class="line">          <span class="keyword">final</span> RelNode transitiveClosureNode =</span><br><span class="line">              transform(PlannerType.HEP, PlannerPhase.TRANSITIVE_CLOSURE, intermediateNode);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Hep 分区剪枝，包含自定义的逻辑优化规则、limit推到scan等</span></span><br><span class="line">          <span class="comment">// 3. PARTITION_PRUNING 限定的规则集合，主要侧重文件系统上的目录文件存储</span></span><br><span class="line">          intermediateNode2 = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.PARTITION_PRUNING, transitiveClosureNode);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 1. VolcanoPlanner 执行 PlannerPhase.LOGICAL_PRUNE 限定的规则</span></span><br><span class="line">          <span class="keyword">final</span> RelNode intermediateNode =</span><br><span class="line">              transform(PlannerType.VOLCANO, PlannerPhase.LOGICAL_PRUNE, pruned, logicalTraits);</span><br><span class="line">          <span class="comment">// 2. HepPlanner 执行 PlannerPhase.TRANSITIVE_CLOSURE 限定的规则</span></span><br><span class="line">          intermediateNode2 = transform(PlannerType.HEP, PlannerPhase.TRANSITIVE_CLOSURE, intermediateNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HepPlanner 执行 PlannerPhase.JOIN_PLANNING 限定的规则，主要是转为DrillJoinRel</span></span><br><span class="line">        intermediateNode3 = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.JOIN_PLANNING, intermediateNode2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认开启</span></span><br><span class="line">        <span class="keyword">if</span> (context.getPlannerSettings().isRowKeyJoinConversionEnabled()) &#123;</span><br><span class="line">          <span class="comment">// 将Join转为主键join，方便join条件下推</span></span><br><span class="line">          convertedRelNode = transform(PlannerType.HEP_BOTTOM_UP, PlannerPhase.ROWKEYJOIN_CONVERSION, intermediateNode3);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          convertedRelNode = intermediateNode3;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> drillRel;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RelOptPlanner.CannotPlanException ex) &#123;</span><br><span class="line">      <span class="comment">//省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-2-物理计划转执行树"><a href="#4-2-物理计划转执行树" class="headerlink" title="4.2 物理计划转执行树"></a>4.2 物理计划转执行树</h5><p>首先，将优化后的物理计划转为多个Fragment，其次，将多个Fragment通过并行器parallelizer形成一个可跨节点执行的fragment树。主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.work.foreman;</span><br><span class="line"><span class="comment">//包引入省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foreman</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> QueryManager queryManager;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于控制算子中buffer的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> QueryResourceManager queryRM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 负责执行local或remote的fragment</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FragmentsRunner fragmentsRunner;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foreman</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 集群模式下是DynamicResourceManager，</span></span><br><span class="line">       <span class="comment">// 通过配置exec.queue.enable 可以任意开启或关闭ThrottledResourceManager</span></span><br><span class="line">       <span class="keyword">this</span>.queryRM = drillbitContext.getResourceManager().newQueryRM(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runPhysicalPlan</span><span class="params">(<span class="keyword">final</span> PhysicalPlan plan, Pointer&lt;String&gt; textPlan)</span> <span class="keyword">throws</span> ExecutionSetupException </span>&#123;</span><br><span class="line">    <span class="comment">// 验证该计划是可执行的</span></span><br><span class="line">    validatePlan(plan);</span><br><span class="line">    <span class="comment">// 为sort、join等算子分配内存</span></span><br><span class="line">    queryRM.visitAbstractPlan(plan);</span><br><span class="line">    <span class="comment">// 封装了fragment的root、child的fragment信息</span></span><br><span class="line">    <span class="keyword">final</span> QueryWorkUnit work = getQueryWorkUnit(plan, queryRM);</span><br><span class="line">    <span class="keyword">if</span> (enableRuntimeFilter) &#123;</span><br><span class="line">      runtimeFilterRouter = <span class="keyword">new</span> RuntimeFilterRouter(work, drillbitContext);</span><br><span class="line">      runtimeFilterRouter.collectRuntimeFilterParallelAndControlInfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (textPlan != <span class="keyword">null</span>) &#123;</span><br><span class="line">      queryManager.setPlanText(textPlan.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算算子需要的内存是否可以获取</span></span><br><span class="line">    queryRM.visitPhysicalPlan(work);</span><br><span class="line">    <span class="comment">// 根据cost判断是large query还是small query</span></span><br><span class="line">    queryRM.setCost(plan.totalCost());</span><br><span class="line">    queryManager.setTotalCost(plan.totalCost());</span><br><span class="line">    <span class="comment">// work将fragment转为json信息</span></span><br><span class="line">    work.applyPlan(drillbitContext.getPlanReader());</span><br><span class="line">    logWorkUnit(work);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将work中的fragment相关信息传给fragmentrunner</span></span><br><span class="line">    fragmentsRunner.setFragmentsInfo(work.getFragments(), work.getRootFragment(), work.getRootOperator());</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 开始查询</span></span><br><span class="line">    startQueryProcessing();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> QueryWorkUnit <span class="title">getQueryWorkUnit</span><span class="params">(<span class="keyword">final</span> PhysicalPlan plan, <span class="keyword">final</span> QueryResourceManager rm)</span> <span class="keyword">throws</span> ExecutionSetupException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> PhysicalOperator rootOperator = plan.getSortedOperators(<span class="keyword">false</span>).iterator().next();</span><br><span class="line">	<span class="comment">// 通过MakeFragmentsVisitor将物理算子分解为构成fragment的各个组成部分</span></span><br><span class="line">    <span class="keyword">final</span> Fragment rootFragment = rootOperator.accept(MakeFragmentsVisitor.INSTANCE, <span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">// 并行器创建工作单元</span></span><br><span class="line">    <span class="comment">// 主要工作是初始化fragment树，基于每个fragment代价进行并行化；</span></span><br><span class="line">    <span class="comment">// 计算每个minor fragment的算子需要的memory</span></span><br><span class="line">    <span class="keyword">return</span> rm.getParallelizer(plan.getProperties().hasResourcePlan).generateWorkUnit(queryContext.getOptions().getOptionList(), queryContext.getCurrentEndpoint(), queryId, queryContext.getOnlineEndpoints(), rootFragment, initiatingClient.getSession(), queryContext.getQueryContextInfo());</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startQueryProcessing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 压入队列，进入QueryState.ENQUEUED状态</span></span><br><span class="line">    <span class="comment">// 如果开启查询队列，先阻塞直到可以查询</span></span><br><span class="line">    enqueue();</span><br><span class="line">    <span class="comment">// fragmentsRunner.submit();</span></span><br><span class="line">    <span class="comment">// 提交root and non-root fragments执行</span></span><br><span class="line">    runFragments();</span><br><span class="line">    queryStateProcessor.moveToState(QueryState.RUNNING, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-3-执行树运行"><a href="#4-3-执行树运行" class="headerlink" title="4.3 执行树运行"></a>4.3 执行树运行</h5><p>(1) 物理执行计划转为执行树后，主要获得三个主要信息<code>FragmentRoot</code>、<code>PlanFragment</code>以及<code>List&lt;PlanFragment&gt;</code>。fragments分发的执行逻辑在FragmentRunner中，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.work.foreman;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentsRunner</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> WorkerBee bee;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> List&lt;PlanFragment&gt; planFragments;</span><br><span class="line">  <span class="keyword">private</span> PlanFragment rootPlanFragment;</span><br><span class="line">  <span class="keyword">private</span> FragmentRoot rootOperator;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionSetupException </span>&#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    logger.debug(<span class="string">"Submitting fragments to run."</span>);</span><br><span class="line">    <span class="comment">// 首先启动root fragment，获取incoming buffers</span></span><br><span class="line">    setupRootFragment(rootPlanFragment, rootOperator);</span><br><span class="line">    <span class="comment">// 启动non root fragment（local or remote）,没有完成前可能会返回数据</span></span><br><span class="line">    setupNonRootFragments(planFragments);</span><br><span class="line">    logger.debug(<span class="string">"Fragments running."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 启动非根fragment</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupNonRootFragments</span><span class="params">(<span class="keyword">final</span> Collection&lt;PlanFragment&gt; fragments)</span> <span class="keyword">throws</span> ExecutionSetupException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fragments.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 向每个节点发送一条消息，不管该节点运行多少fragment</span></span><br><span class="line"><span class="comment">     * 我们需要先运行intermediate fragments处于准备状态，因为leaf fragments一开始运行就会产生数据 </span></span><br><span class="line"><span class="comment">     * 下面将intermediate和leaf fragments分出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Multimap&lt;DrillbitEndpoint, PlanFragment&gt; leafFragmentMap = ArrayListMultimap.create();</span><br><span class="line">    <span class="keyword">final</span> Multimap&lt;DrillbitEndpoint, PlanFragment&gt; intFragmentMap = ArrayListMultimap.create();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里省略分离的逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将intermediate fragments调度到相应的节点准备就绪</span></span><br><span class="line">    scheduleIntermediateFragments(intFragmentMap);</span><br><span class="line"></span><br><span class="line">    injector.injectChecked(foreman.getQueryContext().getExecutionControls(), <span class="string">"send-fragments"</span>, ForemanException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将属于一个节点的所有leaf fragments一个请求发过去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> DrillbitEndpoint ep : leafFragmentMap.keySet()) &#123;</span><br><span class="line">      sendRemoteFragments(ep, leafFragmentMap.get(ep), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2) fragment的接收通过ControlMessageHandler来处理，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.work.batch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlMessageHandler</span> <span class="keyword">implements</span> <span class="title">RequestHandler</span>&lt;<span class="title">ControlConnection</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ControlConnection connection, <span class="keyword">int</span> rpcType, ByteBuf pBody, ByteBuf dBody,ResponseSender sender)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">  	<span class="keyword">switch</span> (rpcType) &#123;</span><br><span class="line">       <span class="comment">// 部分省略</span></span><br><span class="line">            </span><br><span class="line">       <span class="comment">// 接受fragment并初始化</span></span><br><span class="line">       <span class="keyword">case</span> RpcType.REQ_INITIALIZE_FRAGMENTS_VALUE: &#123;</span><br><span class="line">         <span class="keyword">final</span> InitializeFragments fragments = get(pBody, InitializeFragments.PARSER);</span><br><span class="line">         initializeFragment(fragments);</span><br><span class="line">         sender.send(ControlRpcConfig.OK);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Not yet supported."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Ack <span class="title">initializeFragment</span><span class="params">(InitializeFragments fragments)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DrillbitContext drillbitContext = bee.getContext();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fragments.getFragmentCount(); i++) &#123;</span><br><span class="line">      <span class="comment">// 在当前节点启动一个fragment(leaf or intermediate fragment, 本地或远程节点分发过来的)</span></span><br><span class="line">      <span class="comment">// leaf fragment通过FragmentExecutor执行</span></span><br><span class="line">      <span class="comment">// intermediate fragment通过NonRootFragmentManager执行</span></span><br><span class="line">      startNewFragment(fragments.getFragment(i), drillbitContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Acks.OK;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3) leaf fragment通过FragmentExecutor执行，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.work.fragment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentExecutor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> RootExec root; </span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	  <span class="comment">//省略...</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 查询计划中最后一个处理的节点，其他节点包括exchange和storage节点，驱动整个查询</span></span><br><span class="line">      <span class="keyword">final</span> FragmentRoot rootOperator = <span class="keyword">this</span>.rootOperator != <span class="keyword">null</span> ? <span class="keyword">this</span>.rootOperator :</span><br><span class="line">          fragmentContext.getPlanReader().readFragmentRoot(fragment.getFragmentJson());</span><br><span class="line">      <span class="comment">// 根据物理算子树创建RecordBatch树（物理算子实现树）</span></span><br><span class="line">      root = ImplCreator.getExec(fragmentContext, rootOperator);</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// fragment切换到运行状态</span></span><br><span class="line">      updateState(FragmentState.RUNNING);</span><br><span class="line">      <span class="comment">// 获取用户信息</span></span><br><span class="line">      <span class="keyword">final</span> UserGroupInformation queryUserUgi = fragmentContext.isImpersonationEnabled() ? ImpersonationUtil.createProxyUgi(fragmentContext.getQueryUserName()) :ImpersonationUtil.getProcessUserUGI();</span><br><span class="line"></span><br><span class="line">      queryUserUgi.doAs(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          injector.injectChecked(fragmentContext.getExecutionControls(), <span class="string">"fragment-execution"</span>, IOException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (shouldContinue()) &#123;</span><br><span class="line">              </span><br><span class="line">            <span class="keyword">for</span> (FragmentHandle fragmentHandle; (fragmentHandle = receiverFinishedQueue.poll()) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">              <span class="comment">// 针对完成的请求进行处理</span></span><br><span class="line">              root.receivingFragmentFinished(fragmentHandle);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 算子的next，驱动下游算子</span></span><br><span class="line">            <span class="comment">// 比如join、sort、fliter等算子会通过codegen技术提升cpu计算性能</span></span><br><span class="line">            <span class="keyword">if</span> (!root.next()) &#123;</span><br><span class="line">              <span class="comment">// Fragment已经处理完所有数据</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-4-CodeGen"><a href="#4-4-CodeGen" class="headerlink" title="4.4 CodeGen"></a>4.4 CodeGen</h5><p>之所以需要代码生成，是为了提升CPU的执行效率。比如，我们生成的物理执行计划中会存在一些类似if或switch这样的判断逻辑，而在运行时条件的内容已经可知，我们可以直接去掉不必要的分支。另外，运行时可以了解到循环代码的具体循环次数，从而可以将循环展开，同样去除了分支判断逻辑。通过类似这样的优化可以消除分支预测，从而极大的提升性能。可以参考这个<a href="https://yq.aliyun.com/articles/644856" target="_blank" rel="noopener">帖子</a>。</p>
<p>DRILL的算子支持批量的处理，通过代码模板和列式数据，去除无效的分支处理，平铺代码，重新生成充分利用cache和利于CPU计算的代码，并编译交给JVM运行。</p>
<p>比如，拿FilterRecordBatch中的filter算子举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.drill.exec.physical.impl.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterRecordBatch</span> <span class="keyword">extends</span> <span class="title">AbstractSingleRecordBatch</span>&lt;<span class="title">Filter</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//一个选择向量，最多可前置64K个值。用于两种情况：</span></span><br><span class="line">  <span class="comment">// 1. 创建由筛选器保留的值列表</span></span><br><span class="line">  <span class="comment">// 2. 为已排序的批次提供重定向级别</span></span><br><span class="line">  <span class="keyword">private</span> SelectionVector2 sv2;</span><br><span class="line">  <span class="keyword">private</span> Filterer filter;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FilterRecordBatch</span><span class="params">(Filter pop, RecordBatch incoming, FragmentContext context)</span> <span class="keyword">throws</span> OutOfMemoryException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(pop, context, incoming);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setupNewSchema</span><span class="params">()</span> <span class="keyword">throws</span> SchemaChangeException </span>&#123;</span><br><span class="line">    <span class="comment">//清空选择器向量</span></span><br><span class="line">  	<span class="keyword">if</span> (sv2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      sv2.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (incoming.getSchema().getSelectionVectorMode()) &#123;</span><br><span class="line">      <span class="keyword">case</span> NONE:</span><br><span class="line">        <span class="keyword">if</span> (sv2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">          sv2 = <span class="keyword">new</span> SelectionVector2(oContext.getAllocator());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.filter = generateSV2Filterer();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> TWO_BYTE:</span><br><span class="line">        sv2 = <span class="keyword">new</span> SelectionVector2(oContext.getAllocator());</span><br><span class="line">        <span class="keyword">this</span>.filter = generateSV2Filterer();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FOUR_BYTE:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (container.isSchemaChanged()) &#123;</span><br><span class="line">      container.buildSchema(SelectionVectorMode.TWO_BYTE);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> IterOutcome <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    container.zeroVectors();</span><br><span class="line">    <span class="keyword">int</span> recordCount = incoming.getRecordCount();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//执行过滤操作</span></span><br><span class="line">      filter.filterBatch(recordCount);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SchemaChangeException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getFinalOutcome(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建selection vector v2 filterer</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Filterer <span class="title">generateSV2Filterer</span><span class="params">()</span> <span class="keyword">throws</span> SchemaChangeException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ErrorCollector collector = <span class="keyword">new</span> ErrorCollectorImpl();</span><br><span class="line">    <span class="keyword">final</span> List&lt;TransferPair&gt; transfers = Lists.newArrayList();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CodeGenerator用于创建源代码来实现abstract template</span></span><br><span class="line">    <span class="comment">// 它包含多个ClassGenerator，用于实现外部类和内部类，与运行时生成的实例相关联</span></span><br><span class="line">    <span class="comment">// DRILL支持两种方式生成和编译代码。1. 控制字节码 2. java源文件</span></span><br><span class="line">    <span class="keyword">final</span> ClassGenerator&lt;Filterer&gt; cg = CodeGenerator.getRoot(Filterer.TEMPLATE_DEFINITION2, context.getOptions());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LogicalExpression expr = ExpressionTreeMaterializer.materialize(popConfig.getExpr(), incoming, collector,</span><br><span class="line">            context.getFunctionRegistry(), <span class="keyword">false</span>, unionTypeEnabled);</span><br><span class="line">    <span class="keyword">if</span> (collector.hasErrors()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SchemaChangeException(String.format(<span class="string">"Failure while trying to materialize incoming schema.  Errors:\n %s."</span>, collector.toErrorString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cg.addExpr(<span class="keyword">new</span> ReturnValueExpression(expr), ClassGenerator.BlkCreateMode.FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> VectorWrapper&lt;?&gt; v : incoming) &#123;</span><br><span class="line">      <span class="keyword">final</span> TransferPair pair = v.getValueVector().makeTransferPair(container.addOrGet(v.getField(), callBack));</span><br><span class="line">      transfers.add(pair);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> TransferPair[] tx = transfers.toArray(<span class="keyword">new</span> TransferPair[transfers.size()]);</span><br><span class="line">      CodeGenerator&lt;Filterer&gt; codeGen = cg.getCodeGenerator();</span><br><span class="line">      codeGen.plainJavaCapable(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//代码模板和incoming数据相集合，生成高效执行的filter实例</span></span><br><span class="line">      <span class="keyword">final</span> Filterer filter = context.getImplementationClass(codeGen);</span><br><span class="line">      filter.setup(context, incoming, <span class="keyword">this</span>, tx);</span><br><span class="line">      <span class="keyword">return</span> filter;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassTransformationException | IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SchemaChangeException(<span class="string">"Failure while attempting to load generated class"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h4><ul>
<li><a href="http://drill.apache.org/docs" target="_blank" rel="noopener">http://drill.apache.org/docs</a></li>
<li><a href="https://github.com/apache/drill" target="_blank" rel="noopener">https://github.com/apache/drill</a></li>
</ul>
</div><iframe src="/donate/?AliPayQR=/uploads/alipay.png&amp;WeChatQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://changbo.tech/blog/66333501.html" data-id="cksddowgr000qiwvx24qert4x" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAABvUlEQVR42u3aQY7DIAwF0Ln/pTPbkSqoPwbUjh6rKEmTly4s2/jnp7yelzW6Or9//pxtCxcXt819puvvPa/HFe78LXUDLi7ufe4oYoyO52cqQXD+FwzP4+Lifgk3xeHi4v4nbgVdgeLi4n4Lt16czPsVH1Sr4eLiNrj1LuW54yP9XVxc3CXuE650+2QtbA1/i4uLe4Xb2UpJk5i0ZBqWQLi4uFe48wudZCVtqlYMuLi4d7j9bY+1lmslRL5JcXBxcQ9wd41hVcJQ+pG4uLifwK03MevBKE2MNkRcXFzcTdy1QiU9U9+yLVVmuLi4x7hx16Td9Kw3W4fPxMXFPcyNOyjhLETaUnmTcuHi4l7hVsYp1oqWdMwrToZwcXEvcusRo85KG6bxDCkuLu5h7trQVTqM1XkaLi7uHW49hKW49APiDRVcXNzD3HpDJE2SNt+Di4t7mPuEa1drdS0g4uLi3uGudSE693SGP3BxcW9yO8Gr8vp+ERVnZLi4uJu49a3Qc6ENFxf3e7m7yp7FJ+Pi4n4kd/SrtOxZK5NwcXFvcvsDFulWTRqdcHFxb3L7G6iV1meaPG3o7+Li4q5wfwHp69hXrpxMlwAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Drill/">Drill</a><a href="/tags/SQL引擎/">SQL引擎</a><a href="/tags/大数据/">大数据</a><a href="/tags/MPP/">MPP</a></div><div class="post-nav"><a class="pre" href="/blog/1d1f5c7b.html">我的论文</a><a class="next" href="/blog/9ff3ee6b.html">数据库之行列存储简介</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/个人日志/">个人日志</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/云原生/">云原生</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储引擎/">存储引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库与大数据/">数据库与大数据</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器/">服务器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算引擎/">计算引擎</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/">论文阅读</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维工具/">运维工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目管理/">项目管理</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/OLAP/" style="font-size: 15px;">OLAP</a> <a href="/tags/B-树/" style="font-size: 15px;">B+树</a> <a href="/tags/职场感悟/" style="font-size: 15px;">职场感悟</a> <a href="/tags/技术管理/" style="font-size: 15px;">技术管理</a> <a href="/tags/开源协议/" style="font-size: 15px;">开源协议</a> <a href="/tags/Drill/" style="font-size: 15px;">Drill</a> <a href="/tags/查询计划/" style="font-size: 15px;">查询计划</a> <a href="/tags/SQL引擎/" style="font-size: 15px;">SQL引擎</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/MPP/" style="font-size: 15px;">MPP</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/tags/Hive/" style="font-size: 15px;">Hive</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/类加载器/" style="font-size: 15px;">类加载器</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/正向代理/" style="font-size: 15px;">正向代理</a> <a href="/tags/反向代理/" style="font-size: 15px;">反向代理</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/RocksDB/" style="font-size: 15px;">RocksDB</a> <a href="/tags/LSM树/" style="font-size: 15px;">LSM树</a> <a href="/tags/存储引擎/" style="font-size: 15px;">存储引擎</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/业务/" style="font-size: 15px;">业务</a> <a href="/tags/SparkSQL/" style="font-size: 15px;">SparkSQL</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/helm/" style="font-size: 15px;">helm</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/Calcite/" style="font-size: 15px;">Calcite</a> <a href="/tags/优化器/" style="font-size: 15px;">优化器</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/CBO/" style="font-size: 15px;">CBO</a> <a href="/tags/算法复杂度/" style="font-size: 15px;">算法复杂度</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/分布式事务/" style="font-size: 15px;">分布式事务</a> <a href="/tags/ACID/" style="font-size: 15px;">ACID</a> <a href="/tags/CAP/" style="font-size: 15px;">CAP</a> <a href="/tags/Raft/" style="font-size: 15px;">Raft</a> <a href="/tags/分布式一致性/" style="font-size: 15px;">分布式一致性</a> <a href="/tags/AnalyticDB/" style="font-size: 15px;">AnalyticDB</a> <a href="/tags/行列存储/" style="font-size: 15px;">行列存储</a> <a href="/tags/Catalyst/" style="font-size: 15px;">Catalyst</a> <a href="/tags/Intel/" style="font-size: 15px;">Intel</a> <a href="/tags/ARM/" style="font-size: 15px;">ARM</a> <a href="/tags/X86/" style="font-size: 15px;">X86</a> <a href="/tags/硬件/" style="font-size: 15px;">硬件</a> <a href="/tags/RAID/" style="font-size: 15px;">RAID</a> <a href="/tags/服务器/" style="font-size: 15px;">服务器</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/tags/窗口函数/" style="font-size: 15px;">窗口函数</a> <a href="/tags/大数据meetup/" style="font-size: 15px;">大数据meetup</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/IT资讯/" style="font-size: 15px;">IT资讯</a> <a href="/tags/故障诊断/" style="font-size: 15px;">故障诊断</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/书籍/" style="font-size: 15px;">书籍</a> <a href="/tags/论文/" style="font-size: 15px;">论文</a> <a href="/tags/TopK/" style="font-size: 15px;">TopK</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/6d27f500.html">Java类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/b9b847a8.html">SparkSQL业务分析集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/bfe7107d.html">OLAP引擎-Kylin基本介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/ce4ffa9b.html">Hive性能调优实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/19c2ab93.html">Spark性能调优实战</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/c50a937d.html">PMP实践之路</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/7dec2e4.html">Calcite处理和扩展流程解析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/4c70dee6.html">分布式事务与一致性</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/75c48487.html">2020-DTCC-参会分享</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/8fd5028b.html">SparkSQL窗口函数实操</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://changbo.tech/blog/ec4cdf4c.html" title="行业博客" target="_blank">行业博客</a><ul></ul><a href="https://leetcode-cn.com/" title="leetcode" target="_blank">leetcode</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Tony's Notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>