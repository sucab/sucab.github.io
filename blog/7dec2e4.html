<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="bigdata, ai, 中间件、算法、大数据、人工智能"><title>Calcite处理和扩展流程解析 | Tony's Notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Calcite处理和扩展流程解析</h1><a id="logo" href="/.">Tony's Notes</a><p class="description">Stay Hungry, Stay Foolish</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Calcite处理和扩展流程解析</h1><div class="post-meta">Mar 9, 2021<span> | </span><span class="category"><a href="/categories/计算引擎/">计算引擎</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.1k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>相关概述与特性，可以查看之前的文章《<a href="https://changbo.tech/blog/b227762f.html">Calcite原理和经验总结</a>》。</p>
<h1 id="SQL处理流程"><a href="#SQL处理流程" class="headerlink" title="SQL处理流程"></a>SQL处理流程</h1><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><p><img src="/blog/7dec2e4/sql.png" alt></p>
<ul>
<li>Parser（SQL-&gt;SqlNode）： 把 SQL 转换成为 AST （抽象语法树），Calcite 使用 JavaCC 做 SQL 解析.</li>
<li>Validate（SqlNode-&gt;RelNode）： <ul>
<li>语法检查，根据数据库的元数据信息进行语法验证，验证之后还是用 SqlNode 表示 AST 语法树；</li>
<li>语义分析，根据 SqlNode 及元信息构建 RelNode 树，也就是最初版本的逻辑计划（Logical Plan）。</li>
</ul>
</li>
<li>Optimize（RelNode-&gt;RelNode）： <strong>逻辑计划优化，优化器的核心</strong>，根据前面生成的逻辑计划（relational expression，即关系代数）按照相应的规则（Rule）进行优化；</li>
<li>Execute: 物理执行，生成物理计划，物理执行计划执行。</li>
</ul>
<a id="more"></a>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>SqlNode</td>
<td>SQL解析树</td>
<td>Sql 经过解析就会转化SqlNode，然后生成一个未经验证的抽象语法树</td>
</tr>
<tr>
<td>RelNode</td>
<td>relational expression，SqlNode 经过语法分析就会生成RelNode</td>
<td>代表了<strong>对数据的一个处理操作</strong>，常见的操作有 Sort、Join、Project、Filter、Scan 等。它包含了对整个 Relation 的操作，而不是对具体数据的处理逻辑。</td>
</tr>
<tr>
<td>RelOptRule</td>
<td>transforms an expression into another。对 expression 做等价转换</td>
<td>根据它里面的一些规则来对目标 RelNode 树进行局部规则匹配，匹配成功后，则调用 onMatch() 方法进行转换。</td>
</tr>
<tr>
<td>ConverterRule</td>
<td>规则的抽象类，该规则从一种调用规则转化为另一种调用规则而无需更改语义</td>
<td>它是 RelOptRule 的子类，专门用来做数据源之间的转换（Calling convention），<strong>ConverterRule 一般会调用对应的 Converter 来完成工作</strong>，比如说：JdbcToSparkConverterRule 调用 JdbcToSparkConverter 来完成对 JDBC Table 到 Spark RDD 的转换。</td>
</tr>
<tr>
<td>Converter</td>
<td>A relational expression implements the interface <code>Converter</code> to indicate that it converts a physical attribute, or RelTrait of a relational expression from one value to another.</td>
<td><strong>用来把一种 RelTrait 转换为另一种 RelTrait 的 RelNode</strong>。如 JdbcToSparkConverter 可以把 JDBC 里的 table 转换为 Spark RDD。如果需要在一个 RelNode 中处理来源于异构系统的逻辑表，Calcite 要求先用 Converter 把异构系统的逻辑表转换为同一种 Convention。</td>
</tr>
<tr>
<td>RexNode</td>
<td>Row-level expression行表达式</td>
<td>行表达式（标量表达式），蕴含的是对一行数据的处理逻辑。每个行表达式都有数据的类型。这是因为在 Valdiation 的过程中，编译器会推导出表达式的结果类型。常见的行表达式包括字面量 RexLiteral， 变量 RexVariable， 函数或操作符调用 RexCall 等。 RexNode 通过 RexBuilder 进行构建。</td>
</tr>
<tr>
<td>RelTrait</td>
<td>RelTrait表示特征定义中关系表达式特质的表现形式</td>
<td>用来定义逻辑表的物理相关属性（physical property），三种主要的特征类型是：1、<strong>Convention</strong>（用于表示单个数据源的调用约定，一个 relational expression 必须在同一个 convention 中）、2、<strong>RelCollation</strong>（指的是该关系表达式所定义的数据的排序）、3、<strong>RelDistribution</strong>（标识数据的分布特点，比如single、hash、range、random等）；</td>
</tr>
<tr>
<td>RelTraitDef</td>
<td></td>
<td>主要有三种：ConventionTraitDef：用来代表数据源 ；RelCollationTraitDef：用来定义参与排序的字段；RelDistributionTraitDef：用来定义数据在物理存储上的分布方式（比如：single、hash、range、random 等）；</td>
</tr>
<tr>
<td>RelOptCluster</td>
<td>An environment for related relational expressions during the optimization of a query.</td>
<td>palnner运行时的环境，保存上下文信息；</td>
</tr>
<tr>
<td>RelOptPlanner</td>
<td>A RelOptPlanner is a query optimizer: it transforms a relational expression into a semantically equivalent relational expression, according to a given set of rules and a cost model.</td>
<td>也就是<strong>优化器</strong>，Calcite 支持RBO（Rule-Based Optimizer） 和 CBO（Cost-Based Optimizer）。Calcite 的 RBO （HepPlanner）称为启发式优化器（heuristic implementation ），它简单地按 AST 树结构匹配所有已知规则，直到没有规则能够匹配为止；Calcite 的 CBO 称为火山式优化器（VolcanoPlanner）成本优化器也会匹配并应用规则，当整棵树的成本降低趋于稳定后，优化完成，成本优化器依赖于比较准确的成本估算。<strong>RelOptCost 和 Statistic 与成本估算相关</strong>；</td>
</tr>
<tr>
<td>RelOptCost</td>
<td>defines an interface for optimizer cost in terms of number of rows processed, CPU cost, and I/O cost.</td>
<td>主要依赖于IO、CPU、RowCount、memory</td>
</tr>
</tbody>
</table>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>关系是关系模型中用于描述数据的主要结构。包括关系模式（relation schema）和关系实例（relation instance）。</p>
<ul>
<li><p>关系实例：一个二维表。</p>
</li>
<li><p>关系模式：对表的每个列进行描述。</p>
<p>例如：<code>Students(sid:string, name:string, age:integer)</code>。一个关系代数表达式可以用关系、一元或二元代数操作符来递归定义。代数操作符的输入和输出都是关系实例。</p>
</li>
</ul>
<h3 id="关系代数-1"><a href="#关系代数-1" class="headerlink" title="关系代数"></a>关系代数</h3><p>关系代数是关系型数据库操作的理论基础，关系代数支持并、差、笛卡尔积、投影和选择等基本运算。</p>
<p>关系代数也是 Calcite 的核心，任何一个查询都可以表示成由关系运算符组成的树。在 Calcite 中，它会先将 SQL 转换成关系表达式（relational expression），然后通过规则匹配（rules match）进行相应的优化，优化会有一个成本（cost）模型为参考。</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器的作用将解析器生成的关系代数表达式转换成执行计划，供执行引擎执行，在这个过程中，会应用一些规则优化，以帮助生成更高效的执行计划。SQL 查询优化器分为两种类型：</p>
<h3 id="RBO"><a href="#RBO" class="headerlink" title="RBO"></a>RBO</h3><ul>
<li>HepPlanner 是一个启发式优化器；</li>
<li>将会匹配定义的所有 rules 直到一个 rule 被满足；</li>
<li>相比CBO优化器更快；</li>
<li>如果没有每次都不匹配规则，可能会有无限递归风险；</li>
<li>规则是基于经验的，经验就可能是有偏的，总有些问题经验解决解不了。</li>
</ul>
<h3 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h3><ul>
<li>VolcanoPlanner是一个代价优化器；</li>
<li>迭代应用 rules，直到找到cost最小的plan；</li>
<li>成本由关系表达式提供；</li>
<li>不会计算所有可能的计划；</li>
<li>根据已知的情况，如果下面的迭代不能带来提升时，这些计划将会停止优化。</li>
<li><strong>CBO 中有两个依赖：统计信息和代价模型。统计信息的准确与否、代价模型的合理与否都会影响CBO选择最优计划。</strong></li>
</ul>
<p>无论是 RBO，还是 CBO 都包含了一系列优化规则，这些优化规则可以对关系表达式进行等价转换。常见的优化规则包含：谓词下推 Predicate Pushdown、常量折叠 Constant Folding、列裁剪 Column Pruning等等。见如下实例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">10</span>+<span class="number">30</span>, users.name, users.age </span><br><span class="line"><span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">join</span> jobs <span class="keyword">on</span> users.id = jobs.id </span><br><span class="line"><span class="keyword">where</span> users.age &gt; <span class="number">30</span> <span class="keyword">and</span> jobs.id &gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>优化过程如下图所示：</p>
<p><img src="/blog/7dec2e4/sql_optimizer.png" alt></p>
<h3 id="代价模型"><a href="#代价模型" class="headerlink" title="代价模型"></a>代价模型</h3><p>代价模型指的用于计算Cost来选择最优的执行计划，一个好的代价模型可能会影响整个系统的性能。其中，</p>
<ul>
<li>Calcite代价模型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLe</span><span class="params">(RelOptCost other)</span> </span>&#123;</span><br><span class="line">    VolcanoCost that = (VolcanoCost)other;</span><br><span class="line">    <span class="keyword">if</span>(xx) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == that || <span class="keyword">this</span>.rowCount &lt;= that.rowCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == that </span><br><span class="line">        || <span class="keyword">this</span>.rowCount &lt;= that.rowCount</span><br><span class="line">        || <span class="keyword">this</span>.cpu &lt;= that.cpu</span><br><span class="line">        || <span class="keyword">this</span>.io &lt;= that.io</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Ali的MaxComputer代价模型</p>
<p>涉及的指标有：CPU、IO、RowCount、Memory、NetWork</p>
</li>
</ul>
<h1 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h1><h2 id="Schema-amp-Catalog"><a href="#Schema-amp-Catalog" class="headerlink" title="Schema&amp;Catalog"></a>Schema&amp;Catalog</h2><p>用户通过使用SchemaFactory和Schema interfaces来自定义schema。以JSON模型文件声明schemas或者views。通过Table interface自定义table。定义table的record类型。三种表类型：</p>
<ul>
<li>使用ScannableTable interface作为Table的简单实现，来直接枚举所有的rows；</li>
<li>进阶实现FilterableTable，来根据简单的谓词predicates过滤rows；</li>
<li>以TranslatableTable进阶实现Table，将关系型算子转换为执行计划规则；</li>
<li>扩展了CsvStreamScannableTable继承于Scannable Table，流的扩展，即STREAM扩展，窗口扩展，通过联接中的窗口表达式对流的隐式引用等，为流查询提供了支持。</li>
</ul>
<p><img src="/blog/7dec2e4/sql_adapter.png" alt></p>
<p>Catalog主要定义SQL语义相关的元数据与命名空间。Calcite利用schema的层级关系，构造出来namespace的概念，如图所示，schema自身是一个树形结构，这样设计的优点很明显，可以兼容所有已知和未知的数据库，基于namespace结构，schema无论是横向还是纵向都可以无限扩展。</p>
<p><img src="/blog/7dec2e4/schema.png" alt></p>
<h2 id="Avatica"><a href="#Avatica" class="headerlink" title="Avatica"></a>Avatica</h2><p>JDBC驱动程序由Avatica提供支持。Avatica是用于为数据库构建JDBC和ODBC驱动程序以及RPC协议的框架。连接可以是本地连接或远程连接（基于HTTP的JSON或基于HTTP的Protobuf）。JDBC连接字符串的基本形式<code>jdbc:calcite:property=value;property2=value2</code>。</p>
<p><img src="/blog/7dec2e4/avatica.png" alt></p>
<h2 id="CSV适配器示例"><a href="#CSV适配器示例" class="headerlink" title="CSV适配器示例"></a>CSV适配器示例</h2><h3 id="扩展结构"><a href="#扩展结构" class="headerlink" title="扩展结构"></a>扩展结构</h3><p><img src="/blog/7dec2e4/csv.png" alt></p>
<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p><img src="/blog/7dec2e4/model.png" alt></p>
<p><img src="/blog/7dec2e4/model-view.png" alt></p>
<p><img src="/blog/7dec2e4/model-stream.png" alt></p>
<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="Lin4j"><a href="#Lin4j" class="headerlink" title="Lin4j"></a>Lin4j</h2><p>Linq4j（Language-Integrated Query for Java），Calcite可以用于查询多个数据源，而不仅仅是关系数据库。但是，它的目的还不仅仅是支持SQL语言。尽管SQL仍然是主要的数据库语言，但许多程序员还是喜欢LINQ等语言集成语言。与Java或C ++代码中嵌入的SQL不同，语言集成的查询语言允许程序员使用一种语言编写所有代码。 Calcite提供Java语言集成查询（简称LINQ4J），该查询紧密遵循Mirosoft的LINQ为.NET语言制定的约定。</p>
<h2 id="GeoSpatial"><a href="#GeoSpatial" class="headerlink" title="GeoSpatial"></a>GeoSpatial</h2><p>地理空间支持在Calcite中是初步的，使用Calicte的关系代数来实现。 此实现的核心在于添加新的GEOMETRY数据类型，该数据类型封装了不同的几何对象，例如点，曲线和多边形。 预计Calcite将完全符合OpenGIS Simple Feature Access 规范，该规范定义了SQL接口访问地理空间数据的标准。</p>
<h1 id="开源项目应用"><a href="#开源项目应用" class="headerlink" title="开源项目应用"></a>开源项目应用</h1><p><img src="/blog/7dec2e4/calcite_use.png" alt></p>
<h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>Calcite灵活可插拔的架构，使得Hive可以完全使用自己独立的SQL Parser和Validator，<strong>而只用 Calcite 的 Query Optimizer</strong>。而Hive在代码层面和 Calcite 的结合体现在 CalcitePlanner 这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalcitePlanner</span> <span class="keyword">extends</span> <span class="title">SemanticAnalyzer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CalcitePlanner</span><span class="params">(QueryState queryState)</span> <span class="keyword">throws</span> SemanticException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(queryState);</span><br><span class="line">    <span class="keyword">if</span> (!HiveConf.getBoolVar(conf, HiveConf.ConfVars.HIVE_CBO_ENABLED)) &#123;</span><br><span class="line">      runCBO = <span class="keyword">false</span>;</span><br><span class="line">      disableSemJoinReordering = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RelOptPlanner <span class="title">createPlanner</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      HiveConf conf, Set&lt;RelNode&gt; corrScalarRexSQWithAgg,</span></span></span><br><span class="line"><span class="function"><span class="params">      StatsSource statsSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Double maxSplitSize = (<span class="keyword">double</span>) HiveConf.getLongVar(</span><br><span class="line">            conf, HiveConf.ConfVars.MAPREDMAXSPLITSIZE);</span><br><span class="line">    <span class="keyword">final</span> Double maxMemory = (<span class="keyword">double</span>) HiveConf.getLongVar(</span><br><span class="line">            conf, HiveConf.ConfVars.HIVECONVERTJOINNOCONDITIONALTASKTHRESHOLD);</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="keyword">boolean</span> isCorrelatedColumns = HiveConf.getBoolVar(conf, HiveConf.ConfVars.HIVE_CBO_STATS_CORRELATED_MULTI_KEY_JOINS);</span><br><span class="line">    <span class="keyword">boolean</span> heuristicMaterializationStrategy = HiveConf.getVar(conf,</span><br><span class="line">        HiveConf.ConfVars.HIVE_MATERIALIZED_VIEW_REWRITING_SELECTION_STRATEGY).equals(<span class="string">"heuristic"</span>);</span><br><span class="line">    HivePlannerContext confContext = <span class="keyword">new</span> HivePlannerContext(algorithmsConf, registry, calciteConfig,</span><br><span class="line">        corrScalarRexSQWithAgg,</span><br><span class="line">        <span class="keyword">new</span> HiveConfPlannerContext(isCorrelatedColumns, heuristicMaterializationStrategy), statsSource);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> HiveVolcanoPlanner.createPlanner(confContext);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Hive看来，CPU和 IO应该优先级比行数更高，先比较这俩，如果相等，才去看行数。而CPU和IO就不用分那么清楚了，合一起就行，怎么合呢，直接相加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiveVolcanoPlanner</span> <span class="keyword">extends</span> <span class="title">VolcanoPlanner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ENABLE_COLLATION_TRAIT = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isHeuristic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Creates a HiveVolcanoPlanner. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HiveVolcanoPlanner</span><span class="params">(HivePlannerContext conf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(HiveCost.FACTORY, conf);</span><br><span class="line">    isHeuristic = conf.unwrap(HiveConfPlannerContext<span class="class">.<span class="keyword">class</span>).<span class="title">isHeuristicMaterializationStrategy</span>()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RelOptPlanner <span class="title">createPlanner</span><span class="params">(HivePlannerContext conf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> VolcanoPlanner planner = <span class="keyword">new</span> HiveVolcanoPlanner(conf);</span><br><span class="line">    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);</span><br><span class="line">    <span class="keyword">if</span> (ENABLE_COLLATION_TRAIT) &#123;</span><br><span class="line">      planner.addRelTraitDef(RelCollationTraitDef.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> planner;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//其他省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span>&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1. Hivecost normalizes cpu and io in to time.&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 2. CPU, IO cost is added together to find the query latency.&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 3. If query latency is equal then row count is compared.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> This should inherit from VolcanoCost and should just override isLE</span></span><br><span class="line"><span class="comment">// method.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiveCost</span> <span class="keyword">implements</span> <span class="title">RelOptCost</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ~ Instance fields --------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">double</span>                          cpu;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">double</span>                          io;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">double</span>                          rowCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ~ Constructors -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  HiveCost(<span class="keyword">double</span> rowCount, <span class="keyword">double</span> cpu, <span class="keyword">double</span> io) &#123;</span><br><span class="line">    <span class="keyword">assert</span> rowCount &gt;= <span class="number">0</span>d;</span><br><span class="line">    <span class="keyword">assert</span> cpu &gt;= <span class="number">0</span>d;</span><br><span class="line">    <span class="keyword">assert</span> io &gt;= <span class="number">0</span>d;</span><br><span class="line">    <span class="keyword">this</span>.rowCount = rowCount;</span><br><span class="line">    <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    <span class="keyword">this</span>.io = io;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLe</span><span class="params">(RelOptCost other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">this</span>.cpu + <span class="keyword">this</span>.io &lt; other.getCpu() + other.getIo()) ||</span><br><span class="line">          ((<span class="keyword">this</span>.cpu + <span class="keyword">this</span>.io == other.getCpu() + other.getIo()) &amp;&amp;</span><br><span class="line">          (<span class="keyword">this</span>.rowCount &lt;= other.getRows()))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLt</span><span class="params">(RelOptCost other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isLe(other) &amp;&amp; !equals(other);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p>Flink 以Calcite Catalog 为核心，上面承载了 Table API 和 SQL API 两套表达方式，最后殊途同归，统一生成为 Calcite Logical Plan（SqlNode 树）；随后验证、优化为 RelNode 树，最终通过 Rules（规则）和 Convention（转化特征）生成具体的 DataSet Plan（批处理）或 DataStream Plan（流处理），即 Flink 算子构成的处理逻辑。</p>
<p><img src="/blog/7dec2e4/flink.png" alt></p>
<h1 id="未来发展"><a href="#未来发展" class="headerlink" title="未来发展"></a>未来发展</h1><p>Calcite的未来工作将集中在新功能的开发以及其适配器体系结构的扩展上：</p>
<ul>
<li>改进Calcite的设计以进一步支持其使用独立引擎，这将需要对数据定义语言（DDL），物化视图，索引和约束的支持；</li>
<li>不断改进计划程序的设计和灵活性，包括使其更具模块化，从而使用户Calcite可以提供计划程序（规则的集合或合并为计划阶段）以执行；</li>
<li>将新的参数化方法[多目标参数化查询优化]纳入优化器的设计；</li>
<li>支持扩展的SQL命令，功能和实用程序集，包括完全符合OpenGIS；</li>
<li>用于非关系数据源的新适配器，例如用于科学计算的阵列数据库；</li>
<li>改进了性能分析和检测。</li>
</ul>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul>
<li><a href="http://matt33.com/2019/03/07/apache-calcite-process-flow/" target="_blank" rel="noopener">Apache Calcite 处理流程详解（一）</a></li>
<li><a href="http://matt33.com/2019/03/17/apache-calcite-planner/" target="_blank" rel="noopener">Apache Calcite 优化器详解（二）</a></li>
</ul>
</div><iframe src="/donate/?AliPayQR=/uploads/alipay.png&amp;WeChatQR=null&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://changbo.tech/blog/7dec2e4.html" data-id="cksn9fx4y002gfpvxmvbas6c1" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAAByUlEQVR42u3aQYrDMAwF0N7/0hmY1UCp82U5Tjo8r0pKk5cuxLfk1ytex+8aX/l7/dO3yR0WLFxc3Db3GK73W79/7vw2vw8uLu5+7rjQjBHJyyf3j4odLi7uw7hJ6MnLGS4u7v/gjkNJvtXBxcX9Fm5ShsbE5PH5yy/Yq+Hi4ja41YbpFZ8v7O/i4uIWuUdx5eOQPPQUno6Li7uFu2qAOm6RVLdSJy+Mi4u7hTv3mLnCN5dkcHFx7+JWmxp5S7RzXCPq8uLi4i7lJhubJI502ij5t7i4uHu4c1uRzrilOjiJ/mNcXNyl3OqxiU4AqkaiwjkRXFzci7lzLdFqu7MamHBxcXdyqwWlOjrtBJqPz8XFxb2YW215JOWperfCgBYXF/cmbh5i5mJT9RAGLi7ufm51w7Mq3HQCEy4u7tXcfEPSGcrmjdeT0oaLi7uR2xmi5IFmbuHi4t7FzVc+/EhiTfnFcHFxt3CrBSUJPXMNlCRa4eLi7uTmxWtujNo5+lmuvri4uEu5nRNQeTGaK3AfT4vg4uI+gNtpf+RHOk6yGC4u7uO5qw5hjMMTLi7uXdy8Sbp2I5QPd3FxcXdyOw3TuaZq9TouLu5G7g845OceeEau3wAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Calcite/">Calcite</a><a href="/tags/优化器/">优化器</a><a href="/tags/CBO/">CBO</a></div><div class="post-nav"><a class="pre" href="/blog/c50a937d.html">PMP实践之路</a><a class="next" href="/blog/4c70dee6.html">分布式事务与一致性</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/个人日志/">个人日志</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/云原生/">云原生</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/存储引擎/">存储引擎</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库与大数据/">数据库与大数据</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/服务器/">服务器</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程语言/">编程语言</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算引擎/">计算引擎</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/">论文阅读</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维工具/">运维工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目管理/">项目管理</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/OLAP/" style="font-size: 15px;">OLAP</a> <a href="/tags/SQL引擎/" style="font-size: 15px;">SQL引擎</a> <a href="/tags/B-树/" style="font-size: 15px;">B+树</a> <a href="/tags/职场感悟/" style="font-size: 15px;">职场感悟</a> <a href="/tags/技术管理/" style="font-size: 15px;">技术管理</a> <a href="/tags/Drill/" style="font-size: 15px;">Drill</a> <a href="/tags/查询计划/" style="font-size: 15px;">查询计划</a> <a href="/tags/HBase/" style="font-size: 15px;">HBase</a> <a href="/tags/NoSQL/" style="font-size: 15px;">NoSQL</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/大数据/" style="font-size: 15px;">大数据</a> <a href="/tags/MPP/" style="font-size: 15px;">MPP</a> <a href="/tags/Hive/" style="font-size: 15px;">Hive</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/Kylin/" style="font-size: 15px;">Kylin</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/类加载器/" style="font-size: 15px;">类加载器</a> <a href="/tags/业务/" style="font-size: 15px;">业务</a> <a href="/tags/SparkSQL/" style="font-size: 15px;">SparkSQL</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/helm/" style="font-size: 15px;">helm</a> <a href="/tags/kubernetes/" style="font-size: 15px;">kubernetes</a> <a href="/tags/Calcite/" style="font-size: 15px;">Calcite</a> <a href="/tags/优化器/" style="font-size: 15px;">优化器</a> <a href="/tags/CBO/" style="font-size: 15px;">CBO</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/算法复杂度/" style="font-size: 15px;">算法复杂度</a> <a href="/tags/分布式事务/" style="font-size: 15px;">分布式事务</a> <a href="/tags/ACID/" style="font-size: 15px;">ACID</a> <a href="/tags/CAP/" style="font-size: 15px;">CAP</a> <a href="/tags/Raft/" style="font-size: 15px;">Raft</a> <a href="/tags/分布式一致性/" style="font-size: 15px;">分布式一致性</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/AnalyticDB/" style="font-size: 15px;">AnalyticDB</a> <a href="/tags/窗口函数/" style="font-size: 15px;">窗口函数</a> <a href="/tags/Intel/" style="font-size: 15px;">Intel</a> <a href="/tags/ARM/" style="font-size: 15px;">ARM</a> <a href="/tags/X86/" style="font-size: 15px;">X86</a> <a href="/tags/硬件/" style="font-size: 15px;">硬件</a> <a href="/tags/RAID/" style="font-size: 15px;">RAID</a> <a href="/tags/服务器/" style="font-size: 15px;">服务器</a> <a href="/tags/行列存储/" style="font-size: 15px;">行列存储</a> <a href="/tags/Catalyst/" style="font-size: 15px;">Catalyst</a> <a href="/tags/大数据meetup/" style="font-size: 15px;">大数据meetup</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/并发编程/" style="font-size: 15px;">并发编程</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/IT资讯/" style="font-size: 15px;">IT资讯</a> <a href="/tags/故障诊断/" style="font-size: 15px;">故障诊断</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/书籍/" style="font-size: 15px;">书籍</a> <a href="/tags/论文/" style="font-size: 15px;">论文</a> <a href="/tags/TopK/" style="font-size: 15px;">TopK</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/正向代理/" style="font-size: 15px;">正向代理</a> <a href="/tags/反向代理/" style="font-size: 15px;">反向代理</a> <a href="/tags/开源协议/" style="font-size: 15px;">开源协议</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/RocksDB/" style="font-size: 15px;">RocksDB</a> <a href="/tags/LSM树/" style="font-size: 15px;">LSM树</a> <a href="/tags/存储引擎/" style="font-size: 15px;">存储引擎</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/6d27f500.html">Java类加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/b9b847a8.html">SparkSQL业务分析集锦</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/bfe7107d.html">OLAP引擎-Kylin基本介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/ce4ffa9b.html">Hive性能调优实践</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/19c2ab93.html">Spark性能调优实战</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/c50a937d.html">PMP实践之路</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/7dec2e4.html">Calcite处理和扩展流程解析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/4c70dee6.html">分布式事务与一致性</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/75c48487.html">2020-DTCC-参会分享</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/8fd5028b.html">SparkSQL窗口函数实操</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://changbo.tech/blog/ec4cdf4c.html" title="行业博客" target="_blank">行业博客</a><ul></ul><a href="https://leetcode-cn.com/" title="leetcode" target="_blank">leetcode</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Tony's Notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>